{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pybasemkit API Documentation","text":""},{"location":"#basemkit.base_cmd","title":"<code>base_cmd</code>","text":"<p>Created on 2025-06-16</p> <p>Minimal reusable command line base class with standard options.</p> <p>@author: wf</p>"},{"location":"#basemkit.base_cmd.BaseCmd","title":"<code>BaseCmd</code>","text":"<p>Minimal reusable command line base class with standard options: --about, --debug, --force, --quiet, --verbose, --version.</p> <p>Intended to be subclassed by tools requiring consistent CLI behavior.</p> Source code in <code>basemkit/base_cmd.py</code> <pre><code>class BaseCmd:\n    \"\"\"\n    Minimal reusable command line base class with standard options:\n    --about, --debug, --force, --quiet, --verbose, --version.\n\n    Intended to be subclassed by tools requiring consistent CLI behavior.\n    \"\"\"\n\n    def __init__(self, version:Any, description: Optional[str] = None):\n        \"\"\"\n        Initialize the BaseCmd instance.\n\n        Args:\n            version: An object with .name, .version, .description, and .doc_url attributes.\n            description (str): Optional CLI description. Defaults to version.description.\n        \"\"\"\n        self.version = version\n        self.description = description or self.version.description\n        self.program_version_message = f\"{self.version.name} {self.version.version}\"\n        self.debug = False\n        self.quiet = False\n        self.verbose = False\n        self.force = False\n        self.parser = None\n        self.args = None\n\n    def add_arguments(self, parser: ArgumentParser):\n        \"\"\"\n        Add standard CLI arguments to the parser, sorted by long option name.\n\n        Args:\n            parser (ArgumentParser): The parser to add arguments to.\n        \"\"\"\n        parser.add_argument(\n            \"-a\", \"--about\",\n            action=\"store_true\",\n            help=\"show version info and open documentation\"\n        )\n        parser.add_argument(\n            \"-d\", \"--debug\",\n            action=\"store_true\",\n            help=\"enable debug output\"\n        )\n        parser.add_argument(\n            \"--debugLocalPath\",\n            help=\"remote debug Server path mapping - localPath - path on machine where python runs\"\n        )\n        parser.add_argument(\n            \"--debugPort\",\n            type=int,\n            default=5678,\n            help=\"remote debug Port [default: %(default)s]\"\n        )\n        parser.add_argument(\n            \"--debugRemotePath\",\n            help=\"remote debug Server path mapping - remotePath - path on debug server\"\n        )\n        parser.add_argument(\n            \"--debugServer\",\n            help=\"remote debug Server\"\n        )\n        parser.add_argument(\n            \"-f\", \"--force\",\n            action=\"store_true\",\n            help=\"force overwrite or unsafe actions\"\n        )\n        parser.add_argument(\n            \"-q\", \"--quiet\",\n            action=\"store_true\",\n            help=\"suppress all output\"\n        )\n        parser.add_argument(\n            \"-v\", \"--verbose\",\n            action=\"store_true\",\n            help=\"increase output verbosity\"\n        )\n        parser.add_argument(\n            \"-V\", \"--version\",\n            action=\"version\",\n            version=self.program_version_message\n        )\n\n\n    def get_arg_parser(self) -&gt; ArgumentParser:\n        \"\"\"\n        Create and configure the argument parser.\n\n        Returns:\n            ArgumentParser: The configured argument parser.\n        \"\"\"\n        parser = ArgumentParser(description=self.description, formatter_class=RawDescriptionHelpFormatter)\n        self.add_arguments(parser)\n        return parser\n\n    def parse_args(self, argv=None) -&gt; Namespace:\n        \"\"\"\n        Parse command line arguments.\n\n        Args:\n            argv (list): Optional list of command line arguments. Defaults to sys.argv.\n\n        Returns:\n            Namespace: Parsed argument values.\n        \"\"\"\n        if self.parser is None:\n            self.parser = self.get_arg_parser()\n        self.args = self.parser.parse_args(argv)\n        return self.args\n\n    def optional_debug(self, args: Namespace):\n        \"\"\"\n        Optionally start remote debugging if debugServer is specified.\n\n        Args:\n            args (Namespace): Parsed CLI arguments\n        \"\"\"\n        if args.debugServer:\n            import pydevd\n            import pydevd_file_utils\n\n            remote_path = args.debugRemotePath\n            local_path  = args.debugLocalPath\n\n            if remote_path and local_path:\n                pydevd_file_utils.setup_client_server_paths([(remote_path, local_path)])\n\n            pydevd.settrace(\n                args.debugServer,\n                port=args.debugPort,\n                stdoutToServer=True,\n                stderrToServer=True,\n            )\n            print(\"Remote debugger attached.\")\n\n\n    def handle_args(self, args: Namespace) -&gt; bool:\n        \"\"\"\n        Handle parsed arguments. Intended to be overridden in subclasses.\n\n        Args:\n            args (Namespace): Parsed argument namespace.\n\n        Returns:\n            bool: True if argument was handled and no further processing is required.\n        \"\"\"\n        self.args = args\n        self.debug = args.debug\n        self.quiet = args.quiet\n        self.verbose = args.verbose\n        self.force = args.force\n        self.optional_debug(args)\n        if args.about:\n            print(self.program_version_message)\n            print(f\"see {self.version.doc_url}\")\n            webbrowser.open(self.version.doc_url)\n            return True\n\n        return False\n\n    def run(self, argv=None) -&gt; int:\n        \"\"\"\n        Execute the command line logic.\n\n        Args:\n            argv (list): Optional command line arguments.\n\n        Returns:\n            int: Exit code: 0 = OK, 1 = KeyboardInterrupt, 2 = Exception.\n        \"\"\"\n        try:\n            args = self.parse_args(argv)\n            handled = self.handle_args(args)\n            exit_code = 0\n            if not handled:\n                exit_code = 0\n        except KeyboardInterrupt:\n            exit_code = 1\n        except Exception as e:\n            if self.debug:\n                raise\n            sys.stderr.write(f\"{self.version.name}: {e}\\n\")\n            if getattr(self, \"args\", None) and self.args.debug:\n                sys.stderr.write(traceback.format_exc())\n            exit_code = 2\n        return exit_code\n\n    @classmethod\n    def main(cls, version:Any, argv=None) -&gt; int:\n        \"\"\"\n        Entry point for scripts using this command line interface.\n\n        Args:\n            version: Version metadata object passed to constructor.\n            argv (list): Optional command line arguments.\n\n        Returns:\n            int: Exit code from `run()`.\n        \"\"\"\n        instance = cls(version)\n        exit_code = instance.run(argv)\n        return exit_code\n</code></pre>"},{"location":"#basemkit.base_cmd.BaseCmd.__init__","title":"<code>__init__(version, description=None)</code>","text":"<p>Initialize the BaseCmd instance.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>Any</code> <p>An object with .name, .version, .description, and .doc_url attributes.</p> required <code>description</code> <code>str</code> <p>Optional CLI description. Defaults to version.description.</p> <code>None</code> Source code in <code>basemkit/base_cmd.py</code> <pre><code>def __init__(self, version:Any, description: Optional[str] = None):\n    \"\"\"\n    Initialize the BaseCmd instance.\n\n    Args:\n        version: An object with .name, .version, .description, and .doc_url attributes.\n        description (str): Optional CLI description. Defaults to version.description.\n    \"\"\"\n    self.version = version\n    self.description = description or self.version.description\n    self.program_version_message = f\"{self.version.name} {self.version.version}\"\n    self.debug = False\n    self.quiet = False\n    self.verbose = False\n    self.force = False\n    self.parser = None\n    self.args = None\n</code></pre>"},{"location":"#basemkit.base_cmd.BaseCmd.add_arguments","title":"<code>add_arguments(parser)</code>","text":"<p>Add standard CLI arguments to the parser, sorted by long option name.</p> <p>Parameters:</p> Name Type Description Default <code>parser</code> <code>ArgumentParser</code> <p>The parser to add arguments to.</p> required Source code in <code>basemkit/base_cmd.py</code> <pre><code>def add_arguments(self, parser: ArgumentParser):\n    \"\"\"\n    Add standard CLI arguments to the parser, sorted by long option name.\n\n    Args:\n        parser (ArgumentParser): The parser to add arguments to.\n    \"\"\"\n    parser.add_argument(\n        \"-a\", \"--about\",\n        action=\"store_true\",\n        help=\"show version info and open documentation\"\n    )\n    parser.add_argument(\n        \"-d\", \"--debug\",\n        action=\"store_true\",\n        help=\"enable debug output\"\n    )\n    parser.add_argument(\n        \"--debugLocalPath\",\n        help=\"remote debug Server path mapping - localPath - path on machine where python runs\"\n    )\n    parser.add_argument(\n        \"--debugPort\",\n        type=int,\n        default=5678,\n        help=\"remote debug Port [default: %(default)s]\"\n    )\n    parser.add_argument(\n        \"--debugRemotePath\",\n        help=\"remote debug Server path mapping - remotePath - path on debug server\"\n    )\n    parser.add_argument(\n        \"--debugServer\",\n        help=\"remote debug Server\"\n    )\n    parser.add_argument(\n        \"-f\", \"--force\",\n        action=\"store_true\",\n        help=\"force overwrite or unsafe actions\"\n    )\n    parser.add_argument(\n        \"-q\", \"--quiet\",\n        action=\"store_true\",\n        help=\"suppress all output\"\n    )\n    parser.add_argument(\n        \"-v\", \"--verbose\",\n        action=\"store_true\",\n        help=\"increase output verbosity\"\n    )\n    parser.add_argument(\n        \"-V\", \"--version\",\n        action=\"version\",\n        version=self.program_version_message\n    )\n</code></pre>"},{"location":"#basemkit.base_cmd.BaseCmd.get_arg_parser","title":"<code>get_arg_parser()</code>","text":"<p>Create and configure the argument parser.</p> <p>Returns:</p> Name Type Description <code>ArgumentParser</code> <code>ArgumentParser</code> <p>The configured argument parser.</p> Source code in <code>basemkit/base_cmd.py</code> <pre><code>def get_arg_parser(self) -&gt; ArgumentParser:\n    \"\"\"\n    Create and configure the argument parser.\n\n    Returns:\n        ArgumentParser: The configured argument parser.\n    \"\"\"\n    parser = ArgumentParser(description=self.description, formatter_class=RawDescriptionHelpFormatter)\n    self.add_arguments(parser)\n    return parser\n</code></pre>"},{"location":"#basemkit.base_cmd.BaseCmd.handle_args","title":"<code>handle_args(args)</code>","text":"<p>Handle parsed arguments. Intended to be overridden in subclasses.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>Parsed argument namespace.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if argument was handled and no further processing is required.</p> Source code in <code>basemkit/base_cmd.py</code> <pre><code>def handle_args(self, args: Namespace) -&gt; bool:\n    \"\"\"\n    Handle parsed arguments. Intended to be overridden in subclasses.\n\n    Args:\n        args (Namespace): Parsed argument namespace.\n\n    Returns:\n        bool: True if argument was handled and no further processing is required.\n    \"\"\"\n    self.args = args\n    self.debug = args.debug\n    self.quiet = args.quiet\n    self.verbose = args.verbose\n    self.force = args.force\n    self.optional_debug(args)\n    if args.about:\n        print(self.program_version_message)\n        print(f\"see {self.version.doc_url}\")\n        webbrowser.open(self.version.doc_url)\n        return True\n\n    return False\n</code></pre>"},{"location":"#basemkit.base_cmd.BaseCmd.main","title":"<code>main(version, argv=None)</code>  <code>classmethod</code>","text":"<p>Entry point for scripts using this command line interface.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>Any</code> <p>Version metadata object passed to constructor.</p> required <code>argv</code> <code>list</code> <p>Optional command line arguments.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Exit code from <code>run()</code>.</p> Source code in <code>basemkit/base_cmd.py</code> <pre><code>@classmethod\ndef main(cls, version:Any, argv=None) -&gt; int:\n    \"\"\"\n    Entry point for scripts using this command line interface.\n\n    Args:\n        version: Version metadata object passed to constructor.\n        argv (list): Optional command line arguments.\n\n    Returns:\n        int: Exit code from `run()`.\n    \"\"\"\n    instance = cls(version)\n    exit_code = instance.run(argv)\n    return exit_code\n</code></pre>"},{"location":"#basemkit.base_cmd.BaseCmd.optional_debug","title":"<code>optional_debug(args)</code>","text":"<p>Optionally start remote debugging if debugServer is specified.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>Parsed CLI arguments</p> required Source code in <code>basemkit/base_cmd.py</code> <pre><code>def optional_debug(self, args: Namespace):\n    \"\"\"\n    Optionally start remote debugging if debugServer is specified.\n\n    Args:\n        args (Namespace): Parsed CLI arguments\n    \"\"\"\n    if args.debugServer:\n        import pydevd\n        import pydevd_file_utils\n\n        remote_path = args.debugRemotePath\n        local_path  = args.debugLocalPath\n\n        if remote_path and local_path:\n            pydevd_file_utils.setup_client_server_paths([(remote_path, local_path)])\n\n        pydevd.settrace(\n            args.debugServer,\n            port=args.debugPort,\n            stdoutToServer=True,\n            stderrToServer=True,\n        )\n        print(\"Remote debugger attached.\")\n</code></pre>"},{"location":"#basemkit.base_cmd.BaseCmd.parse_args","title":"<code>parse_args(argv=None)</code>","text":"<p>Parse command line arguments.</p> <p>Parameters:</p> Name Type Description Default <code>argv</code> <code>list</code> <p>Optional list of command line arguments. Defaults to sys.argv.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Namespace</code> <code>Namespace</code> <p>Parsed argument values.</p> Source code in <code>basemkit/base_cmd.py</code> <pre><code>def parse_args(self, argv=None) -&gt; Namespace:\n    \"\"\"\n    Parse command line arguments.\n\n    Args:\n        argv (list): Optional list of command line arguments. Defaults to sys.argv.\n\n    Returns:\n        Namespace: Parsed argument values.\n    \"\"\"\n    if self.parser is None:\n        self.parser = self.get_arg_parser()\n    self.args = self.parser.parse_args(argv)\n    return self.args\n</code></pre>"},{"location":"#basemkit.base_cmd.BaseCmd.run","title":"<code>run(argv=None)</code>","text":"<p>Execute the command line logic.</p> <p>Parameters:</p> Name Type Description Default <code>argv</code> <code>list</code> <p>Optional command line arguments.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Exit code: 0 = OK, 1 = KeyboardInterrupt, 2 = Exception.</p> Source code in <code>basemkit/base_cmd.py</code> <pre><code>def run(self, argv=None) -&gt; int:\n    \"\"\"\n    Execute the command line logic.\n\n    Args:\n        argv (list): Optional command line arguments.\n\n    Returns:\n        int: Exit code: 0 = OK, 1 = KeyboardInterrupt, 2 = Exception.\n    \"\"\"\n    try:\n        args = self.parse_args(argv)\n        handled = self.handle_args(args)\n        exit_code = 0\n        if not handled:\n            exit_code = 0\n    except KeyboardInterrupt:\n        exit_code = 1\n    except Exception as e:\n        if self.debug:\n            raise\n        sys.stderr.write(f\"{self.version.name}: {e}\\n\")\n        if getattr(self, \"args\", None) and self.args.debug:\n            sys.stderr.write(traceback.format_exc())\n        exit_code = 2\n    return exit_code\n</code></pre>"},{"location":"#basemkit.basetest","title":"<code>basetest</code>","text":"<p>Created on 2021-08-19</p> <p>@author: wf</p>"},{"location":"#basemkit.basetest.Basetest","title":"<code>Basetest</code>","text":"<p>               Bases: <code>TestCase</code></p> <p>base test case</p> Source code in <code>basemkit/basetest.py</code> <pre><code>class Basetest(unittest.TestCase):\n    \"\"\"\n    base test case\n    \"\"\"\n\n    def setUp(self, debug=False, profile=True):\n        \"\"\"\n        setUp test environment\n        \"\"\"\n        unittest.TestCase.setUp(self)\n        self.debug = debug\n        self.profile = profile\n        msg = f\"test {self._testMethodName}, debug={self.debug}\"\n        self.profiler = Profiler(msg, profile=self.profile)\n\n    def tearDown(self):\n        unittest.TestCase.tearDown(self)\n        self.profiler.time()\n\n    @staticmethod\n    def inPublicCI():\n        \"\"\"\n        are we running in a public Continuous Integration Environment?\n        \"\"\"\n        publicCI = getpass.getuser() in [\"travis\", \"runner\"]\n        jenkins = \"JENKINS_HOME\" in os.environ\n        return publicCI or jenkins\n\n    @staticmethod\n    def isUser(name: str):\n        \"\"\"Checks if the system has the given name\"\"\"\n        return getpass.getuser() == name\n\n    @staticmethod\n    def timeout(seconds: float) -&gt; Callable:\n        \"\"\"\n        Decorator to enforce a timeout on test methods.\n\n        Args:\n            seconds (float): Timeout duration in seconds.\n\n        Returns:\n            Callable: A decorator that wraps a function and raises TimeoutError\n                      if it exceeds the allowed execution time.\n\n        Raises:\n            TimeoutError: If the wrapped function exceeds the timeout.\n            Exception: If the wrapped function raises any other exception.\n        \"\"\"\n\n        def decorator(func):\n            @wraps(func)\n            def wrapper(*args, **kwargs):\n                result = [None]\n                exception = [None]\n\n                def target():\n                    try:\n                        result[0] = func(*args, **kwargs)\n                    except Exception as e:\n                        exception[0] = e\n\n                thread = threading.Thread(target=target)\n                thread.start()\n                thread.join(seconds)\n\n                if thread.is_alive():\n                    raise TimeoutError(f\"Test timed out after {seconds} seconds\")\n\n                if exception[0] is not None:\n                    raise exception[0]\n\n                return result[0]\n\n            return wrapper\n\n        return decorator\n</code></pre>"},{"location":"#basemkit.basetest.Basetest.inPublicCI","title":"<code>inPublicCI()</code>  <code>staticmethod</code>","text":"<p>are we running in a public Continuous Integration Environment?</p> Source code in <code>basemkit/basetest.py</code> <pre><code>@staticmethod\ndef inPublicCI():\n    \"\"\"\n    are we running in a public Continuous Integration Environment?\n    \"\"\"\n    publicCI = getpass.getuser() in [\"travis\", \"runner\"]\n    jenkins = \"JENKINS_HOME\" in os.environ\n    return publicCI or jenkins\n</code></pre>"},{"location":"#basemkit.basetest.Basetest.isUser","title":"<code>isUser(name)</code>  <code>staticmethod</code>","text":"<p>Checks if the system has the given name</p> Source code in <code>basemkit/basetest.py</code> <pre><code>@staticmethod\ndef isUser(name: str):\n    \"\"\"Checks if the system has the given name\"\"\"\n    return getpass.getuser() == name\n</code></pre>"},{"location":"#basemkit.basetest.Basetest.setUp","title":"<code>setUp(debug=False, profile=True)</code>","text":"<p>setUp test environment</p> Source code in <code>basemkit/basetest.py</code> <pre><code>def setUp(self, debug=False, profile=True):\n    \"\"\"\n    setUp test environment\n    \"\"\"\n    unittest.TestCase.setUp(self)\n    self.debug = debug\n    self.profile = profile\n    msg = f\"test {self._testMethodName}, debug={self.debug}\"\n    self.profiler = Profiler(msg, profile=self.profile)\n</code></pre>"},{"location":"#basemkit.basetest.Basetest.timeout","title":"<code>timeout(seconds)</code>  <code>staticmethod</code>","text":"<p>Decorator to enforce a timeout on test methods.</p> <p>Parameters:</p> Name Type Description Default <code>seconds</code> <code>float</code> <p>Timeout duration in seconds.</p> required <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable</code> <p>A decorator that wraps a function and raises TimeoutError       if it exceeds the allowed execution time.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the wrapped function exceeds the timeout.</p> <code>Exception</code> <p>If the wrapped function raises any other exception.</p> Source code in <code>basemkit/basetest.py</code> <pre><code>@staticmethod\ndef timeout(seconds: float) -&gt; Callable:\n    \"\"\"\n    Decorator to enforce a timeout on test methods.\n\n    Args:\n        seconds (float): Timeout duration in seconds.\n\n    Returns:\n        Callable: A decorator that wraps a function and raises TimeoutError\n                  if it exceeds the allowed execution time.\n\n    Raises:\n        TimeoutError: If the wrapped function exceeds the timeout.\n        Exception: If the wrapped function raises any other exception.\n    \"\"\"\n\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            result = [None]\n            exception = [None]\n\n            def target():\n                try:\n                    result[0] = func(*args, **kwargs)\n                except Exception as e:\n                    exception[0] = e\n\n            thread = threading.Thread(target=target)\n            thread.start()\n            thread.join(seconds)\n\n            if thread.is_alive():\n                raise TimeoutError(f\"Test timed out after {seconds} seconds\")\n\n            if exception[0] is not None:\n                raise exception[0]\n\n            return result[0]\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"#basemkit.persistent_log","title":"<code>persistent_log</code>","text":"<p>Created on 2024-10-04</p> <p>@author: wf</p>"},{"location":"#basemkit.persistent_log.Log","title":"<code>Log</code>","text":"<p>Wrapper for persistent logging.</p> Source code in <code>basemkit/persistent_log.py</code> <pre><code>@lod_storable\nclass Log:\n    \"\"\"\n    Wrapper for persistent logging.\n    \"\"\"\n\n    entries: List[LogEntry] = field(default_factory=list)\n\n    def color_msg(self, color, msg):\n        \"\"\"Display a colored message\"\"\"\n        print(f\"{color}{msg}{END_COLOR}\")\n\n    def __post_init__(self):\n        \"\"\"\n        Initializes the log with level mappings and updates the level counts.\n        \"\"\"\n        self.do_log = True\n        self.do_print = False\n        self.levels = {\"\u274c\": logging.ERROR, \"\u26a0\ufe0f\": logging.WARNING, \"\u2705\": logging.INFO}\n        self.level_names = {\n            logging.ERROR: \"error\",\n            logging.WARNING: \"warn\",\n            logging.INFO: \"info\",\n        }\n        self.update_level_counts()\n\n    def clear(self):\n        \"\"\"\n        Clears all log entries.\n        \"\"\"\n        self.entries = []\n        self.update_level_counts()\n\n    def update_level_counts(self):\n        \"\"\"\n        Updates the counts for each log level based on the existing entries.\n        \"\"\"\n        self.level_counts = {\"error\": Counter(), \"warn\": Counter(), \"info\": Counter()}\n        for entry in self.entries:\n            counter = self.get_counter(entry.level_name)\n            if counter is not None:\n                counter[entry.kind] += 1\n\n    def get_counter(self, level: str) -&gt; Counter:\n        \"\"\"\n        Returns the counter for the specified log level.\n        \"\"\"\n        return self.level_counts.get(level)\n\n    def get_level_summary(self, level: str, limit: int = 7) -&gt; Tuple[int, str]:\n        \"\"\"\n        Get a summary of the most common counts for the specified log level.\n\n        Args:\n            level (str): The log level name ('error', 'warn', 'info').\n            limit (int): The maximum number of most common entries to include in the summary (default is 7).\n\n        Returns:\n            Tuple[int, str]: A tuple containing the count of log entries and a summary message.\n        \"\"\"\n        counter = self.get_counter(level)\n        if counter:\n            count = sum(counter.values())\n            most_common_entries = dict(counter.most_common(limit))  # Get the top 'limit' entries\n            summary_msg = f\"{level.capitalize()} entries: {most_common_entries}\"\n            return count, summary_msg\n        return 0, f\"No entries found for level: {level}\"\n\n    def log(self, icon: str, kind: str, msg: str):\n        \"\"\"\n        Log a message with the specified icon and kind.\n\n        Args:\n            icon (str): The icon representing the log level ('\u274c', '\u26a0\ufe0f', '\u2705').\n            kind (str): The category or type of the log message.\n            msg (str): The log message to record.\n        \"\"\"\n        level = self.levels.get(icon, logging.INFO)\n        level_name = self.level_names[level]\n        icon_msg = f\"{icon}:{msg}\"\n        log_entry = LogEntry(msg=icon_msg, level_name=level_name, kind=kind)\n        self.entries.append(log_entry)\n\n        # Update level counts\n        self.level_counts[level_name][kind] += 1\n\n        if self.do_log:\n            logging.log(level, icon_msg)\n        if self.do_print:\n            print(icon_msg)\n</code></pre>"},{"location":"#basemkit.persistent_log.Log.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Initializes the log with level mappings and updates the level counts.</p> Source code in <code>basemkit/persistent_log.py</code> <pre><code>def __post_init__(self):\n    \"\"\"\n    Initializes the log with level mappings and updates the level counts.\n    \"\"\"\n    self.do_log = True\n    self.do_print = False\n    self.levels = {\"\u274c\": logging.ERROR, \"\u26a0\ufe0f\": logging.WARNING, \"\u2705\": logging.INFO}\n    self.level_names = {\n        logging.ERROR: \"error\",\n        logging.WARNING: \"warn\",\n        logging.INFO: \"info\",\n    }\n    self.update_level_counts()\n</code></pre>"},{"location":"#basemkit.persistent_log.Log.clear","title":"<code>clear()</code>","text":"<p>Clears all log entries.</p> Source code in <code>basemkit/persistent_log.py</code> <pre><code>def clear(self):\n    \"\"\"\n    Clears all log entries.\n    \"\"\"\n    self.entries = []\n    self.update_level_counts()\n</code></pre>"},{"location":"#basemkit.persistent_log.Log.color_msg","title":"<code>color_msg(color, msg)</code>","text":"<p>Display a colored message</p> Source code in <code>basemkit/persistent_log.py</code> <pre><code>def color_msg(self, color, msg):\n    \"\"\"Display a colored message\"\"\"\n    print(f\"{color}{msg}{END_COLOR}\")\n</code></pre>"},{"location":"#basemkit.persistent_log.Log.get_counter","title":"<code>get_counter(level)</code>","text":"<p>Returns the counter for the specified log level.</p> Source code in <code>basemkit/persistent_log.py</code> <pre><code>def get_counter(self, level: str) -&gt; Counter:\n    \"\"\"\n    Returns the counter for the specified log level.\n    \"\"\"\n    return self.level_counts.get(level)\n</code></pre>"},{"location":"#basemkit.persistent_log.Log.get_level_summary","title":"<code>get_level_summary(level, limit=7)</code>","text":"<p>Get a summary of the most common counts for the specified log level.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>str</code> <p>The log level name ('error', 'warn', 'info').</p> required <code>limit</code> <code>int</code> <p>The maximum number of most common entries to include in the summary (default is 7).</p> <code>7</code> <p>Returns:</p> Type Description <code>Tuple[int, str]</code> <p>Tuple[int, str]: A tuple containing the count of log entries and a summary message.</p> Source code in <code>basemkit/persistent_log.py</code> <pre><code>def get_level_summary(self, level: str, limit: int = 7) -&gt; Tuple[int, str]:\n    \"\"\"\n    Get a summary of the most common counts for the specified log level.\n\n    Args:\n        level (str): The log level name ('error', 'warn', 'info').\n        limit (int): The maximum number of most common entries to include in the summary (default is 7).\n\n    Returns:\n        Tuple[int, str]: A tuple containing the count of log entries and a summary message.\n    \"\"\"\n    counter = self.get_counter(level)\n    if counter:\n        count = sum(counter.values())\n        most_common_entries = dict(counter.most_common(limit))  # Get the top 'limit' entries\n        summary_msg = f\"{level.capitalize()} entries: {most_common_entries}\"\n        return count, summary_msg\n    return 0, f\"No entries found for level: {level}\"\n</code></pre>"},{"location":"#basemkit.persistent_log.Log.log","title":"<code>log(icon, kind, msg)</code>","text":"<p>Log a message with the specified icon and kind.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>str</code> <p>The icon representing the log level ('\u274c', '\u26a0\ufe0f', '\u2705').</p> required <code>kind</code> <code>str</code> <p>The category or type of the log message.</p> required <code>msg</code> <code>str</code> <p>The log message to record.</p> required Source code in <code>basemkit/persistent_log.py</code> <pre><code>def log(self, icon: str, kind: str, msg: str):\n    \"\"\"\n    Log a message with the specified icon and kind.\n\n    Args:\n        icon (str): The icon representing the log level ('\u274c', '\u26a0\ufe0f', '\u2705').\n        kind (str): The category or type of the log message.\n        msg (str): The log message to record.\n    \"\"\"\n    level = self.levels.get(icon, logging.INFO)\n    level_name = self.level_names[level]\n    icon_msg = f\"{icon}:{msg}\"\n    log_entry = LogEntry(msg=icon_msg, level_name=level_name, kind=kind)\n    self.entries.append(log_entry)\n\n    # Update level counts\n    self.level_counts[level_name][kind] += 1\n\n    if self.do_log:\n        logging.log(level, icon_msg)\n    if self.do_print:\n        print(icon_msg)\n</code></pre>"},{"location":"#basemkit.persistent_log.Log.update_level_counts","title":"<code>update_level_counts()</code>","text":"<p>Updates the counts for each log level based on the existing entries.</p> Source code in <code>basemkit/persistent_log.py</code> <pre><code>def update_level_counts(self):\n    \"\"\"\n    Updates the counts for each log level based on the existing entries.\n    \"\"\"\n    self.level_counts = {\"error\": Counter(), \"warn\": Counter(), \"info\": Counter()}\n    for entry in self.entries:\n        counter = self.get_counter(entry.level_name)\n        if counter is not None:\n            counter[entry.kind] += 1\n</code></pre>"},{"location":"#basemkit.persistent_log.LogEntry","title":"<code>LogEntry</code>","text":"<p>Represents a log entry with a message, kind, and log level name.</p> Source code in <code>basemkit/persistent_log.py</code> <pre><code>@lod_storable\nclass LogEntry:\n    \"\"\"\n    Represents a log entry with a message, kind, and log level name.\n    \"\"\"\n\n    msg: str\n    kind: str\n    level_name: str\n    timestamp: Optional[str] = None\n\n    def __post_init__(self):\n        if self.timestamp is None:\n            self.timestamp = datetime.now().isoformat()\n</code></pre>"},{"location":"#basemkit.profiler","title":"<code>profiler</code>","text":"<p>Created on 2022-11-18</p> <p>@author: wf</p>"},{"location":"#basemkit.profiler.Profiler","title":"<code>Profiler</code>","text":"<p>simple profiler</p> Source code in <code>basemkit/profiler.py</code> <pre><code>class Profiler:\n    \"\"\"\n    simple profiler\n    \"\"\"\n\n    def __init__(self, msg: str, profile=True, with_start: bool = True):\n        \"\"\"\n        Construct the profiler with the given message and flags.\n\n        Args:\n            msg (str): The message to show if profiling is active.\n            profile (bool): True if profiling messages should be shown.\n            with_start (bool): If True, show start message immediately.\n        \"\"\"\n        self.msg = msg\n        self.profile = profile\n        if with_start:\n            self.start()\n\n    def start(self):\n        \"\"\"\n        start profiling\n        \"\"\"\n        self.starttime = time.time()\n        if self.profile:\n            print(f\"Starting {self.msg} ...\")\n\n    def time(self, extraMsg: str = \"\"):\n        \"\"\"\n        time the action and print if profile is active\n        \"\"\"\n        elapsed = time.time() - self.starttime\n        if self.profile:\n            print(f\"{self.msg}{extraMsg} took {elapsed:5.1f} s\")\n        return elapsed\n</code></pre>"},{"location":"#basemkit.profiler.Profiler.__init__","title":"<code>__init__(msg, profile=True, with_start=True)</code>","text":"<p>Construct the profiler with the given message and flags.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message to show if profiling is active.</p> required <code>profile</code> <code>bool</code> <p>True if profiling messages should be shown.</p> <code>True</code> <code>with_start</code> <code>bool</code> <p>If True, show start message immediately.</p> <code>True</code> Source code in <code>basemkit/profiler.py</code> <pre><code>def __init__(self, msg: str, profile=True, with_start: bool = True):\n    \"\"\"\n    Construct the profiler with the given message and flags.\n\n    Args:\n        msg (str): The message to show if profiling is active.\n        profile (bool): True if profiling messages should be shown.\n        with_start (bool): If True, show start message immediately.\n    \"\"\"\n    self.msg = msg\n    self.profile = profile\n    if with_start:\n        self.start()\n</code></pre>"},{"location":"#basemkit.profiler.Profiler.start","title":"<code>start()</code>","text":"<p>start profiling</p> Source code in <code>basemkit/profiler.py</code> <pre><code>def start(self):\n    \"\"\"\n    start profiling\n    \"\"\"\n    self.starttime = time.time()\n    if self.profile:\n        print(f\"Starting {self.msg} ...\")\n</code></pre>"},{"location":"#basemkit.profiler.Profiler.time","title":"<code>time(extraMsg='')</code>","text":"<p>time the action and print if profile is active</p> Source code in <code>basemkit/profiler.py</code> <pre><code>def time(self, extraMsg: str = \"\"):\n    \"\"\"\n    time the action and print if profile is active\n    \"\"\"\n    elapsed = time.time() - self.starttime\n    if self.profile:\n        print(f\"{self.msg}{extraMsg} took {elapsed:5.1f} s\")\n    return elapsed\n</code></pre>"},{"location":"#basemkit.shell","title":"<code>shell</code>","text":"<p>Created on 2025-05-14</p> <p>@author: wf</p>"},{"location":"#basemkit.shell.Shell","title":"<code>Shell</code>","text":"<p>Runs commands with environment from profile</p> Source code in <code>basemkit/shell.py</code> <pre><code>class Shell:\n    \"\"\"\n    Runs commands with environment from profile\n    \"\"\"\n\n    def __init__(self, profile:str=None, shell_path: str = None):\n        \"\"\"\n        Initialize shell with optional profile\n\n        Args:\n            profile: Path to profile file to source e.g. ~/.zprofile\n            shell_path: the shell_path e.g. /bin/zsh\n        \"\"\"\n        self.profile = profile\n        self.shell_path = shell_path\n        if self.shell_path is None:\n            self.shell_path = os.environ.get(\"SHELL\", \"/bin/bash\")\n        self.shell_name = os.path.basename(self.shell_path)\n        if self.profile is None:\n            self.profile = self.find_profile()\n\n    def find_profile(self) -&gt; str:\n        \"\"\"\n        Find the appropriate profile file for the current shell\n\n        Searches for the profile file corresponding to the shell_name\n        in the user's home directory.\n\n        Returns:\n            str: Path to the profile file or None if not found\n        \"\"\"\n        profile = None\n        home = os.path.expanduser(\"~\")\n        # Try common profile files\n        profiles = {\"zsh\": \".zprofile\", \"bash\": \".bash_profile\", \"sh\": \".profile\"}\n        if self.shell_name in profiles:\n            profile_name = profiles[self.shell_name]\n            path = os.path.join(home, profile_name)\n            if os.path.exists(path):\n                profile = path\n        return profile\n\n    @classmethod\n    def ofArgs(cls, args:Namespace)-&gt;'Shell':\n        \"\"\"\n        Create Shell from command line args\n\n        Args:\n            args: Arguments with optional profile\n\n        Returns:\n            Shell: Configured Shell\n        \"\"\"\n        # Use explicit profile or detect\n        profile = getattr(args, \"profile\", None)\n        shell = cls(profile=profile)\n        return shell\n\n    def run(self, cmd:str, text:bool=True, debug:bool=False, tee:bool=False) -&gt; subprocess.CompletedProcess:\n        \"\"\"\n        Run command with profile, always capturing output and optionally teeing it.\n\n        Args:\n            cmd: Command to run\n            text: Text mode for subprocess I/O\n            debug: Print the command to be run\n            tee: If True, also print output live while capturing\n\n        Returns:\n            subprocess.CompletedProcess\n        \"\"\"\n        shell_cmd = f\"source {self.profile} &amp;&amp; {cmd}\" if self.profile else cmd\n\n        if debug:\n            print(f\"Running: {shell_cmd}\")\n\n        popen_process = subprocess.Popen(\n            [self.shell_path, \"-c\", shell_cmd],\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            text=text,\n        )\n\n        std_tee = StdTee.run(popen_process, tee=tee)\n        returncode = popen_process.wait()\n\n        process = subprocess.CompletedProcess(\n            args=popen_process.args,\n            returncode=returncode,\n            stdout=std_tee.stdout_buffer.getvalue(),\n            stderr=std_tee.stderr_buffer.getvalue(),\n        )\n\n        if process.returncode != 0:\n            if debug:\n                msg = f\"\"\"{process.args} failed:\n  returncode: {process.returncode}\n  stdout    : {process.stdout.strip()}\n  stderr    : {process.stderr.strip()}\n\"\"\"\n                print(msg, file=sys.stderr)\n            pass\n\n        return process\n\n    def proc_stats(\n        self,\n        title: str,\n        procs: Dict[Path, subprocess.CompletedProcess],\n        ignores: List[str] = [],\n    ):\n        \"\"\"\n        Show process statistics with checkmark/crossmark and success/failure summary.\n\n        Args:\n            title (str): A short title to label the output section.\n            procs (Dict[Path, subprocess.CompletedProcess]): Mapping of input files to their process results.\n            ignores (List[str], optional): List of substrings. If any is found in stderr, the error is ignored.\n        \"\"\"\n        total = len(procs)\n        failures = 0\n        print(f\"\\n{total} {title}:\")\n        for idx, (path, result) in enumerate(procs.items(), start=1):\n            stderr = result.stderr or \"\"\n            stdout = result.stdout or \"\"\n            ignored = any(ignore in stderr for ignore in ignores)\n            has_error = (stderr and not ignored) or (\"Error\" in stdout)\n            if has_error:\n                symbol = \"\u274c\"\n                failures += 1\n            else:\n                symbol = \"\u2705\"\n            print(f\"{symbol} {idx}/{total}: {path.name}\")\n        percent_ok = ((total - failures) / total) * 100 if total &gt; 0 else 0\n        print(f\"\\n\u2705 {total - failures}/{total} ({percent_ok:.1f}%), \u274c {failures}/{total} ({100 - percent_ok:.1f}%)\")\n</code></pre>"},{"location":"#basemkit.shell.Shell.__init__","title":"<code>__init__(profile=None, shell_path=None)</code>","text":"<p>Initialize shell with optional profile</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>str</code> <p>Path to profile file to source e.g. ~/.zprofile</p> <code>None</code> <code>shell_path</code> <code>str</code> <p>the shell_path e.g. /bin/zsh</p> <code>None</code> Source code in <code>basemkit/shell.py</code> <pre><code>def __init__(self, profile:str=None, shell_path: str = None):\n    \"\"\"\n    Initialize shell with optional profile\n\n    Args:\n        profile: Path to profile file to source e.g. ~/.zprofile\n        shell_path: the shell_path e.g. /bin/zsh\n    \"\"\"\n    self.profile = profile\n    self.shell_path = shell_path\n    if self.shell_path is None:\n        self.shell_path = os.environ.get(\"SHELL\", \"/bin/bash\")\n    self.shell_name = os.path.basename(self.shell_path)\n    if self.profile is None:\n        self.profile = self.find_profile()\n</code></pre>"},{"location":"#basemkit.shell.Shell.find_profile","title":"<code>find_profile()</code>","text":"<p>Find the appropriate profile file for the current shell</p> <p>Searches for the profile file corresponding to the shell_name in the user's home directory.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Path to the profile file or None if not found</p> Source code in <code>basemkit/shell.py</code> <pre><code>def find_profile(self) -&gt; str:\n    \"\"\"\n    Find the appropriate profile file for the current shell\n\n    Searches for the profile file corresponding to the shell_name\n    in the user's home directory.\n\n    Returns:\n        str: Path to the profile file or None if not found\n    \"\"\"\n    profile = None\n    home = os.path.expanduser(\"~\")\n    # Try common profile files\n    profiles = {\"zsh\": \".zprofile\", \"bash\": \".bash_profile\", \"sh\": \".profile\"}\n    if self.shell_name in profiles:\n        profile_name = profiles[self.shell_name]\n        path = os.path.join(home, profile_name)\n        if os.path.exists(path):\n            profile = path\n    return profile\n</code></pre>"},{"location":"#basemkit.shell.Shell.ofArgs","title":"<code>ofArgs(args)</code>  <code>classmethod</code>","text":"<p>Create Shell from command line args</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>Arguments with optional profile</p> required <p>Returns:</p> Name Type Description <code>Shell</code> <code>Shell</code> <p>Configured Shell</p> Source code in <code>basemkit/shell.py</code> <pre><code>@classmethod\ndef ofArgs(cls, args:Namespace)-&gt;'Shell':\n    \"\"\"\n    Create Shell from command line args\n\n    Args:\n        args: Arguments with optional profile\n\n    Returns:\n        Shell: Configured Shell\n    \"\"\"\n    # Use explicit profile or detect\n    profile = getattr(args, \"profile\", None)\n    shell = cls(profile=profile)\n    return shell\n</code></pre>"},{"location":"#basemkit.shell.Shell.proc_stats","title":"<code>proc_stats(title, procs, ignores=[])</code>","text":"<p>Show process statistics with checkmark/crossmark and success/failure summary.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>A short title to label the output section.</p> required <code>procs</code> <code>Dict[Path, CompletedProcess]</code> <p>Mapping of input files to their process results.</p> required <code>ignores</code> <code>List[str]</code> <p>List of substrings. If any is found in stderr, the error is ignored.</p> <code>[]</code> Source code in <code>basemkit/shell.py</code> <pre><code>def proc_stats(\n    self,\n    title: str,\n    procs: Dict[Path, subprocess.CompletedProcess],\n    ignores: List[str] = [],\n):\n    \"\"\"\n    Show process statistics with checkmark/crossmark and success/failure summary.\n\n    Args:\n        title (str): A short title to label the output section.\n        procs (Dict[Path, subprocess.CompletedProcess]): Mapping of input files to their process results.\n        ignores (List[str], optional): List of substrings. If any is found in stderr, the error is ignored.\n    \"\"\"\n    total = len(procs)\n    failures = 0\n    print(f\"\\n{total} {title}:\")\n    for idx, (path, result) in enumerate(procs.items(), start=1):\n        stderr = result.stderr or \"\"\n        stdout = result.stdout or \"\"\n        ignored = any(ignore in stderr for ignore in ignores)\n        has_error = (stderr and not ignored) or (\"Error\" in stdout)\n        if has_error:\n            symbol = \"\u274c\"\n            failures += 1\n        else:\n            symbol = \"\u2705\"\n        print(f\"{symbol} {idx}/{total}: {path.name}\")\n    percent_ok = ((total - failures) / total) * 100 if total &gt; 0 else 0\n    print(f\"\\n\u2705 {total - failures}/{total} ({percent_ok:.1f}%), \u274c {failures}/{total} ({100 - percent_ok:.1f}%)\")\n</code></pre>"},{"location":"#basemkit.shell.Shell.run","title":"<code>run(cmd, text=True, debug=False, tee=False)</code>","text":"<p>Run command with profile, always capturing output and optionally teeing it.</p> <p>Parameters:</p> Name Type Description Default <code>cmd</code> <code>str</code> <p>Command to run</p> required <code>text</code> <code>bool</code> <p>Text mode for subprocess I/O</p> <code>True</code> <code>debug</code> <code>bool</code> <p>Print the command to be run</p> <code>False</code> <code>tee</code> <code>bool</code> <p>If True, also print output live while capturing</p> <code>False</code> <p>Returns:</p> Type Description <code>CompletedProcess</code> <p>subprocess.CompletedProcess</p> Source code in <code>basemkit/shell.py</code> <pre><code>    def run(self, cmd:str, text:bool=True, debug:bool=False, tee:bool=False) -&gt; subprocess.CompletedProcess:\n        \"\"\"\n        Run command with profile, always capturing output and optionally teeing it.\n\n        Args:\n            cmd: Command to run\n            text: Text mode for subprocess I/O\n            debug: Print the command to be run\n            tee: If True, also print output live while capturing\n\n        Returns:\n            subprocess.CompletedProcess\n        \"\"\"\n        shell_cmd = f\"source {self.profile} &amp;&amp; {cmd}\" if self.profile else cmd\n\n        if debug:\n            print(f\"Running: {shell_cmd}\")\n\n        popen_process = subprocess.Popen(\n            [self.shell_path, \"-c\", shell_cmd],\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            text=text,\n        )\n\n        std_tee = StdTee.run(popen_process, tee=tee)\n        returncode = popen_process.wait()\n\n        process = subprocess.CompletedProcess(\n            args=popen_process.args,\n            returncode=returncode,\n            stdout=std_tee.stdout_buffer.getvalue(),\n            stderr=std_tee.stderr_buffer.getvalue(),\n        )\n\n        if process.returncode != 0:\n            if debug:\n                msg = f\"\"\"{process.args} failed:\n  returncode: {process.returncode}\n  stdout    : {process.stdout.strip()}\n  stderr    : {process.stderr.strip()}\n\"\"\"\n                print(msg, file=sys.stderr)\n            pass\n\n        return process\n</code></pre>"},{"location":"#basemkit.shell.ShellResult","title":"<code>ShellResult</code>","text":"<p>result of a command line call</p> Source code in <code>basemkit/shell.py</code> <pre><code>class ShellResult:\n    \"\"\"\n    result of a command line call\n    \"\"\"\n\n    def __init__(self, proc, success: bool):\n        self.proc = proc\n        self.success = success\n\n    def __str__(self):\n        text = self.as_text()\n        return text\n\n    def as_text(self, debug: bool = False):\n        if debug:\n            text = f\"{self.proc.args} \u2192 rc={self.proc.returncode}, success={self.success}\"\n        else:\n            text = \"\u2705\" if self.success else f\"\u274c \u2192 rc={self.proc.returncode}\"\n        return text\n</code></pre>"},{"location":"#basemkit.shell.StdTee","title":"<code>StdTee</code>","text":"<p>Manages teeing for both stdout and stderr using StreamTee instances. Captures output in instance variables.</p> Source code in <code>basemkit/shell.py</code> <pre><code>class StdTee:\n    \"\"\"\n    Manages teeing for both stdout and stderr using StreamTee instances.\n    Captures output in instance variables.\n    \"\"\"\n\n    def __init__(self, process, tee=True):\n        self.stdout_buffer = io.StringIO()\n        self.stderr_buffer = io.StringIO()\n        self.out_tee = StreamTee(process.stdout, sys.stdout, self.stdout_buffer, tee)\n        self.err_tee = StreamTee(process.stderr, sys.stderr, self.stderr_buffer, tee)\n\n    def start(self):\n        self.out_tee.start()\n        self.err_tee.start()\n\n    def join(self):\n        self.out_tee.join()\n        self.err_tee.join()\n\n    @classmethod\n    def run(cls, process, tee=True):\n        \"\"\"\n        Run teeing and capture for the given process.\n        Returns a StdTee instance with stdout/stderr captured.\n        \"\"\"\n        std_tee = cls(process, tee=tee)\n        std_tee.start()\n        std_tee.join()\n        return std_tee\n</code></pre>"},{"location":"#basemkit.shell.StdTee.run","title":"<code>run(process, tee=True)</code>  <code>classmethod</code>","text":"<p>Run teeing and capture for the given process. Returns a StdTee instance with stdout/stderr captured.</p> Source code in <code>basemkit/shell.py</code> <pre><code>@classmethod\ndef run(cls, process, tee=True):\n    \"\"\"\n    Run teeing and capture for the given process.\n    Returns a StdTee instance with stdout/stderr captured.\n    \"\"\"\n    std_tee = cls(process, tee=tee)\n    std_tee.start()\n    std_tee.join()\n    return std_tee\n</code></pre>"},{"location":"#basemkit.shell.StreamTee","title":"<code>StreamTee</code>","text":"<p>Tees a single input stream to both a mirror and a capture buffer.</p> Source code in <code>basemkit/shell.py</code> <pre><code>class StreamTee:\n    \"\"\"\n    Tees a single input stream to both a mirror and a capture buffer.\n    \"\"\"\n\n    def __init__(self, source, mirror, buffer, tee=True):\n        self.source = source\n        self.mirror = mirror\n        self.buffer = buffer\n        self.tee = tee\n        self.thread = threading.Thread(target=self._run, daemon=True)\n\n    def _run(self):\n        for line in iter(self.source.readline, \"\"):\n            if self.tee:\n                self.mirror.write(line)\n                self.mirror.flush()\n            self.buffer.write(line)\n        self.source.close()\n\n    def start(self):\n        self.thread.start()\n\n    def join(self):\n        self.thread.join()\n</code></pre>"},{"location":"#basemkit.shell.SysTee","title":"<code>SysTee</code>","text":"<p>Tee sys.stdout and sys.stderr to a logfile while preserving original output.</p> Source code in <code>basemkit/shell.py</code> <pre><code>class SysTee:\n    \"\"\"\n    Tee sys.stdout and sys.stderr to a logfile while preserving original output.\n    \"\"\"\n\n    def __init__(self, log_path: str):\n        self.logfile = open(log_path, \"a\")\n        self.original_stdout = sys.stdout\n        self.original_stderr = sys.stderr\n        sys.stdout = self\n        sys.stderr = self\n\n    def write(self, data):\n        self.original_stdout.write(data)\n        self.logfile.write(data)\n\n    def flush(self):\n        self.original_stdout.flush()\n        self.logfile.flush()\n\n    def close(self):\n        sys.stdout = self.original_stdout\n        sys.stderr = self.original_stderr\n        self.logfile.close()\n</code></pre>"},{"location":"#basemkit.yamlable","title":"<code>yamlable</code>","text":"<p>Created on 2023-12-08, Extended on 2023-16-12 and 2024-01-25</p> <p>@author: wf, ChatGPT</p> <p>Prompts for the development and extension of the 'YamlAble' class within the 'yamable' module:</p> <ol> <li>Develop 'YamlAble' class in 'yamable' module. It    should convert dataclass instances to/from YAML.</li> <li>Implement methods for YAML block scalar style and    exclude None values in 'YamlAble' class.</li> <li>Add functionality to remove None values from    dataclass instances before YAML conversion.</li> <li>Ensure 'YamlAble' processes only dataclass instances,    with error handling for non-dataclass objects.</li> <li>Extend 'YamlAble' for JSON serialization and    deserialization.</li> <li>Add methods for saving/loading dataclass instances    to/from YAML and JSON files in 'YamlAble'.</li> <li>Implement loading of dataclass instances from URLs    for both YAML and JSON in 'YamlAble'.</li> <li>Write tests for 'YamlAble' within the pyLodStorage context.    Use 'samples 2' example from pyLoDStorage    https://github.com/WolfgangFahl/pyLoDStorage/blob/master/lodstorage/sample2.py    as a reference.</li> <li>Ensure tests cover YAML/JSON serialization, deserialization,    and file I/O operations, using the sample-based approach..</li> <li>Use Google-style docstrings, comments, and type hints    in 'YamlAble' class and tests.</li> <li>Adhere to instructions and seek clarification for     any uncertainties.</li> <li>Add @lod_storable annotation support that will automatically     YamlAble support and add @dataclass and @dataclass_json     prerequisite behavior to a class</li> </ol>"},{"location":"#basemkit.yamlable.DateConvert","title":"<code>DateConvert</code>","text":"<p>date converter</p> Source code in <code>basemkit/yamlable.py</code> <pre><code>class DateConvert:\n    \"\"\"\n    date converter\n    \"\"\"\n\n    @classmethod\n    def iso_date_to_datetime(cls, iso_date: str) -&gt; date:\n        date = datetime.strptime(iso_date, \"%Y-%m-%d\").date() if iso_date else None\n        return date\n</code></pre>"},{"location":"#basemkit.yamlable.YamlAble","title":"<code>YamlAble</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>An extended YAML handler class for converting dataclass objects to and from YAML format, and handling loading from and saving to files and URLs.</p> Source code in <code>basemkit/yamlable.py</code> <pre><code>class YamlAble(Generic[T]):\n    \"\"\"\n    An extended YAML handler class for converting dataclass objects to and from YAML format,\n    and handling loading from and saving to files and URLs.\n    \"\"\"\n\n    def _yaml_setup(self):\n        \"\"\"\n        Initializes the YamAble handler, setting up custom representers and preparing it for various operations.\n        \"\"\"\n        if not is_dataclass(self):\n            raise ValueError(\"I must be a dataclass instance.\")\n        if not hasattr(self, \"_yaml_dumper\"):\n            self._yaml_dumper = yaml.Dumper\n            self._yaml_dumper.ignore_aliases = lambda *_args: True\n            self._yaml_dumper.add_representer(type(None), self.represent_none)\n            self._yaml_dumper.add_representer(str, self.represent_literal)\n\n    def represent_none(self, _, __) -&gt; yaml.Node:\n        \"\"\"\n        Custom representer for ignoring None values in the YAML output.\n        \"\"\"\n        return self._yaml_dumper.represent_scalar(\"tag:yaml.org,2002:null\", \"\")\n\n    def represent_literal(self, dumper: yaml.Dumper, data: str) -&gt; yaml.Node:\n        \"\"\"\n        Custom representer for block scalar style for strings.\n        \"\"\"\n        if \"\\n\" in data:\n            return dumper.represent_scalar(\"tag:yaml.org,2002:str\", data, style=\"|\")\n        return dumper.represent_scalar(\"tag:yaml.org,2002:str\", data)\n\n    def to_yaml(\n        self,\n        ignore_none: bool = True,\n        ignore_underscore: bool = True,\n        allow_unicode: bool = True,\n        sort_keys: bool = False,\n    ) -&gt; str:\n        \"\"\"\n        Converts this dataclass object to a YAML string, with options to omit None values and/or underscore-prefixed variables,\n        and using block scalar style for strings.\n\n        Args:\n            ignore_none: Flag to indicate whether None values should be removed from the YAML output.\n            ignore_underscore: Flag to indicate whether attributes starting with an underscore should be excluded from the YAML output.\n            allow_unicode: Flag to indicate whether to allow unicode characters in the output.\n            sort_keys: Flag to indicate whether to sort the dictionary keys in the output.\n\n        Returns:\n            A string representation of the dataclass object in YAML format.\n        \"\"\"\n        obj_dict = asdict(self)\n        self._yaml_setup()\n        clean_dict = self.remove_ignored_values(obj_dict, ignore_none, ignore_underscore)\n        yaml_str = yaml.dump(\n            clean_dict,\n            Dumper=self._yaml_dumper,\n            default_flow_style=False,\n            allow_unicode=allow_unicode,\n            sort_keys=sort_keys,\n        )\n        return yaml_str\n\n    @classmethod\n    def from_yaml(cls: Type[T], yaml_str: str) -&gt; T:\n        \"\"\"\n        Deserializes a YAML string to a dataclass instance.\n\n        Args:\n            yaml_str (str): A string containing YAML formatted data.\n\n        Returns:\n            T: An instance of the dataclass.\n        \"\"\"\n        data: dict[str, Any] = yaml.safe_load(yaml_str)\n        instance: T = cls.from_dict(data)\n        return instance\n\n    @classmethod\n    def load_from_yaml_stream(cls: Type[T], stream: TextIO) -&gt; T:\n        \"\"\"\n        Loads a dataclass instance from a YAML stream.\n\n        Args:\n            stream (TextIO): The input stream containing YAML data.\n\n        Returns:\n            T: An instance of the dataclass.\n        \"\"\"\n        yaml_str: str = stream.read()\n        instance: T = cls.from_yaml(yaml_str)\n        return instance\n\n    @classmethod\n    def load_from_yaml_file(cls: Type[T], filename: str) -&gt; T:\n        \"\"\"\n        Loads a dataclass instance from a YAML file.\n\n        Args:\n            filename (str): The path to the YAML file.\n\n        Returns:\n            T: An instance of the dataclass.\n        \"\"\"\n        with open(filename, \"r\") as file:\n            return cls.load_from_yaml_stream(file)\n\n    @classmethod\n    def load_from_yaml_url(cls: Type[T], url: str) -&gt; T:\n        \"\"\"\n        Loads a dataclass instance from a YAML string obtained from a URL.\n\n        Args:\n            url (str): The URL pointing to the YAML data.\n\n        Returns:\n            T: An instance of the dataclass.\n        \"\"\"\n        yaml_str: str = cls.read_from_url(url)\n        instance: T = cls.from_yaml(yaml_str)\n        return instance\n\n    def save_to_yaml_stream(self, file: TextIO):\n        \"\"\"\n        Saves the current dataclass instance to the given YAML stream.\n\n        Args:\n            file (TextIO): The stream to which YAML content will be saved.\n        \"\"\"\n        yaml_content: str = self.to_yaml()\n        file.write(yaml_content)\n\n    def save_to_yaml_file(self, filename: str):\n        \"\"\"\n        Saves the current dataclass instance to a YAML file.\n\n        Args:\n            filename (str): The path where the YAML file will be saved.\n        \"\"\"\n\n        with open(filename, \"w\", encoding=\"utf-8\") as file:\n            self.save_to_yaml_stream(file)\n\n    @classmethod\n    def load_from_json_file(cls: Type[T], filename: Union[str, Path]) -&gt; T:\n        \"\"\"\n        Loads a dataclass instance from a JSON file.\n\n        Args:\n            filename (str): The path to the JSON file.\n\n        Returns:\n            T: An instance of the dataclass.\n        \"\"\"\n        with open(filename, \"r\", encoding=\"utf-8\") as file:\n            json_str: str = file.read()\n        instance: T = cls.from_json(json_str)\n        return instance\n\n    @classmethod\n    def load_from_json_url(cls: Type[T], url: str) -&gt; T:\n        \"\"\"\n        Loads a dataclass instance from a JSON string obtained from a URL.\n\n        Args:\n            url (str): The URL pointing to the JSON data.\n\n        Returns:\n            T: An instance of the dataclass.\n        \"\"\"\n        json_str: str = cls.read_from_url(url)\n        instance: T = cls.from_json(json_str)\n        return instance\n\n    def save_to_json_file(self, filename: str, **kwargs: Any):\n        \"\"\"\n        Saves the current dataclass instance to a JSON file.\n\n        Args:\n            filename (str): The path where the JSON file will be saved.\n            **kwargs: Additional keyword arguments for the `to_json` method.\n        \"\"\"\n        json_content: str = self.to_json(**kwargs)\n        with open(filename, \"w\", encoding=\"utf-8\") as file:\n            file.write(json_content)\n\n    @classmethod\n    def read_from_url(cls, url: str) -&gt; str:\n        \"\"\"\n        Helper method to fetch content from a URL.\n        \"\"\"\n        with urllib.request.urlopen(url) as response:\n            if response.status == 200:\n                return response.read().decode()\n            else:\n                raise Exception(f\"Unable to load data from URL: {url}\")\n\n    @classmethod\n    def remove_ignored_values(\n        cls,\n        value: Any,\n        ignore_none: bool = True,\n        ignore_underscore: bool = False,\n        ignore_empty: bool = True,\n    ) -&gt; Any:\n        \"\"\"\n        Recursively removes specified types of values from a dictionary or list.\n        By default, it removes keys with None values. Optionally, it can also remove keys starting with an underscore.\n\n        Args:\n            value: The value to process (dictionary, list, or other).\n            ignore_none: Flag to indicate whether None values should be removed.\n            ignore_underscore: Flag to indicate whether keys starting with an underscore should be removed.\n            ignore_empty: Flag to indicate whether empty collections should be removed.\n        \"\"\"\n\n        def is_valid(v):\n            \"\"\"Check if the value is valid based on the specified flags.\"\"\"\n            if ignore_none and v is None:\n                return False\n            if ignore_empty:\n                if isinstance(v, Mapping) and not v:\n                    return False  # Empty dictionary\n                if isinstance(v, Iterable) and not isinstance(v, (str, bytes)) and not v:\n                    return False  # Empty list, set, tuple, etc., but not string or bytes\n            return True\n\n        if isinstance(value, Mapping):\n            value = {\n                k: YamlAble.remove_ignored_values(v, ignore_none, ignore_underscore, ignore_empty)\n                for k, v in value.items()\n                if is_valid(v) and (not ignore_underscore or not k.startswith(\"_\"))\n            }\n        elif isinstance(value, Iterable) and not isinstance(value, (str, bytes)):\n            value = [\n                YamlAble.remove_ignored_values(v, ignore_none, ignore_underscore, ignore_empty)\n                for v in value\n                if is_valid(v)\n            ]\n        return value\n\n    @classmethod\n    def from_dict2(cls: Type[T], data: dict) -&gt; T:\n        \"\"\"\n        Creates an instance of a dataclass from a dictionary, typically used in deserialization.\n        \"\"\"\n        if not data:\n            return None\n        instance = from_dict(data_class=cls, data=data)\n        return instance\n</code></pre>"},{"location":"#basemkit.yamlable.YamlAble.from_dict2","title":"<code>from_dict2(data)</code>  <code>classmethod</code>","text":"<p>Creates an instance of a dataclass from a dictionary, typically used in deserialization.</p> Source code in <code>basemkit/yamlable.py</code> <pre><code>@classmethod\ndef from_dict2(cls: Type[T], data: dict) -&gt; T:\n    \"\"\"\n    Creates an instance of a dataclass from a dictionary, typically used in deserialization.\n    \"\"\"\n    if not data:\n        return None\n    instance = from_dict(data_class=cls, data=data)\n    return instance\n</code></pre>"},{"location":"#basemkit.yamlable.YamlAble.from_yaml","title":"<code>from_yaml(yaml_str)</code>  <code>classmethod</code>","text":"<p>Deserializes a YAML string to a dataclass instance.</p> <p>Parameters:</p> Name Type Description Default <code>yaml_str</code> <code>str</code> <p>A string containing YAML formatted data.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>An instance of the dataclass.</p> Source code in <code>basemkit/yamlable.py</code> <pre><code>@classmethod\ndef from_yaml(cls: Type[T], yaml_str: str) -&gt; T:\n    \"\"\"\n    Deserializes a YAML string to a dataclass instance.\n\n    Args:\n        yaml_str (str): A string containing YAML formatted data.\n\n    Returns:\n        T: An instance of the dataclass.\n    \"\"\"\n    data: dict[str, Any] = yaml.safe_load(yaml_str)\n    instance: T = cls.from_dict(data)\n    return instance\n</code></pre>"},{"location":"#basemkit.yamlable.YamlAble.load_from_json_file","title":"<code>load_from_json_file(filename)</code>  <code>classmethod</code>","text":"<p>Loads a dataclass instance from a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the JSON file.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>An instance of the dataclass.</p> Source code in <code>basemkit/yamlable.py</code> <pre><code>@classmethod\ndef load_from_json_file(cls: Type[T], filename: Union[str, Path]) -&gt; T:\n    \"\"\"\n    Loads a dataclass instance from a JSON file.\n\n    Args:\n        filename (str): The path to the JSON file.\n\n    Returns:\n        T: An instance of the dataclass.\n    \"\"\"\n    with open(filename, \"r\", encoding=\"utf-8\") as file:\n        json_str: str = file.read()\n    instance: T = cls.from_json(json_str)\n    return instance\n</code></pre>"},{"location":"#basemkit.yamlable.YamlAble.load_from_json_url","title":"<code>load_from_json_url(url)</code>  <code>classmethod</code>","text":"<p>Loads a dataclass instance from a JSON string obtained from a URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL pointing to the JSON data.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>An instance of the dataclass.</p> Source code in <code>basemkit/yamlable.py</code> <pre><code>@classmethod\ndef load_from_json_url(cls: Type[T], url: str) -&gt; T:\n    \"\"\"\n    Loads a dataclass instance from a JSON string obtained from a URL.\n\n    Args:\n        url (str): The URL pointing to the JSON data.\n\n    Returns:\n        T: An instance of the dataclass.\n    \"\"\"\n    json_str: str = cls.read_from_url(url)\n    instance: T = cls.from_json(json_str)\n    return instance\n</code></pre>"},{"location":"#basemkit.yamlable.YamlAble.load_from_yaml_file","title":"<code>load_from_yaml_file(filename)</code>  <code>classmethod</code>","text":"<p>Loads a dataclass instance from a YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the YAML file.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>An instance of the dataclass.</p> Source code in <code>basemkit/yamlable.py</code> <pre><code>@classmethod\ndef load_from_yaml_file(cls: Type[T], filename: str) -&gt; T:\n    \"\"\"\n    Loads a dataclass instance from a YAML file.\n\n    Args:\n        filename (str): The path to the YAML file.\n\n    Returns:\n        T: An instance of the dataclass.\n    \"\"\"\n    with open(filename, \"r\") as file:\n        return cls.load_from_yaml_stream(file)\n</code></pre>"},{"location":"#basemkit.yamlable.YamlAble.load_from_yaml_stream","title":"<code>load_from_yaml_stream(stream)</code>  <code>classmethod</code>","text":"<p>Loads a dataclass instance from a YAML stream.</p> <p>Parameters:</p> Name Type Description Default <code>stream</code> <code>TextIO</code> <p>The input stream containing YAML data.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>An instance of the dataclass.</p> Source code in <code>basemkit/yamlable.py</code> <pre><code>@classmethod\ndef load_from_yaml_stream(cls: Type[T], stream: TextIO) -&gt; T:\n    \"\"\"\n    Loads a dataclass instance from a YAML stream.\n\n    Args:\n        stream (TextIO): The input stream containing YAML data.\n\n    Returns:\n        T: An instance of the dataclass.\n    \"\"\"\n    yaml_str: str = stream.read()\n    instance: T = cls.from_yaml(yaml_str)\n    return instance\n</code></pre>"},{"location":"#basemkit.yamlable.YamlAble.load_from_yaml_url","title":"<code>load_from_yaml_url(url)</code>  <code>classmethod</code>","text":"<p>Loads a dataclass instance from a YAML string obtained from a URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL pointing to the YAML data.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>An instance of the dataclass.</p> Source code in <code>basemkit/yamlable.py</code> <pre><code>@classmethod\ndef load_from_yaml_url(cls: Type[T], url: str) -&gt; T:\n    \"\"\"\n    Loads a dataclass instance from a YAML string obtained from a URL.\n\n    Args:\n        url (str): The URL pointing to the YAML data.\n\n    Returns:\n        T: An instance of the dataclass.\n    \"\"\"\n    yaml_str: str = cls.read_from_url(url)\n    instance: T = cls.from_yaml(yaml_str)\n    return instance\n</code></pre>"},{"location":"#basemkit.yamlable.YamlAble.read_from_url","title":"<code>read_from_url(url)</code>  <code>classmethod</code>","text":"<p>Helper method to fetch content from a URL.</p> Source code in <code>basemkit/yamlable.py</code> <pre><code>@classmethod\ndef read_from_url(cls, url: str) -&gt; str:\n    \"\"\"\n    Helper method to fetch content from a URL.\n    \"\"\"\n    with urllib.request.urlopen(url) as response:\n        if response.status == 200:\n            return response.read().decode()\n        else:\n            raise Exception(f\"Unable to load data from URL: {url}\")\n</code></pre>"},{"location":"#basemkit.yamlable.YamlAble.remove_ignored_values","title":"<code>remove_ignored_values(value, ignore_none=True, ignore_underscore=False, ignore_empty=True)</code>  <code>classmethod</code>","text":"<p>Recursively removes specified types of values from a dictionary or list. By default, it removes keys with None values. Optionally, it can also remove keys starting with an underscore.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to process (dictionary, list, or other).</p> required <code>ignore_none</code> <code>bool</code> <p>Flag to indicate whether None values should be removed.</p> <code>True</code> <code>ignore_underscore</code> <code>bool</code> <p>Flag to indicate whether keys starting with an underscore should be removed.</p> <code>False</code> <code>ignore_empty</code> <code>bool</code> <p>Flag to indicate whether empty collections should be removed.</p> <code>True</code> Source code in <code>basemkit/yamlable.py</code> <pre><code>@classmethod\ndef remove_ignored_values(\n    cls,\n    value: Any,\n    ignore_none: bool = True,\n    ignore_underscore: bool = False,\n    ignore_empty: bool = True,\n) -&gt; Any:\n    \"\"\"\n    Recursively removes specified types of values from a dictionary or list.\n    By default, it removes keys with None values. Optionally, it can also remove keys starting with an underscore.\n\n    Args:\n        value: The value to process (dictionary, list, or other).\n        ignore_none: Flag to indicate whether None values should be removed.\n        ignore_underscore: Flag to indicate whether keys starting with an underscore should be removed.\n        ignore_empty: Flag to indicate whether empty collections should be removed.\n    \"\"\"\n\n    def is_valid(v):\n        \"\"\"Check if the value is valid based on the specified flags.\"\"\"\n        if ignore_none and v is None:\n            return False\n        if ignore_empty:\n            if isinstance(v, Mapping) and not v:\n                return False  # Empty dictionary\n            if isinstance(v, Iterable) and not isinstance(v, (str, bytes)) and not v:\n                return False  # Empty list, set, tuple, etc., but not string or bytes\n        return True\n\n    if isinstance(value, Mapping):\n        value = {\n            k: YamlAble.remove_ignored_values(v, ignore_none, ignore_underscore, ignore_empty)\n            for k, v in value.items()\n            if is_valid(v) and (not ignore_underscore or not k.startswith(\"_\"))\n        }\n    elif isinstance(value, Iterable) and not isinstance(value, (str, bytes)):\n        value = [\n            YamlAble.remove_ignored_values(v, ignore_none, ignore_underscore, ignore_empty)\n            for v in value\n            if is_valid(v)\n        ]\n    return value\n</code></pre>"},{"location":"#basemkit.yamlable.YamlAble.represent_literal","title":"<code>represent_literal(dumper, data)</code>","text":"<p>Custom representer for block scalar style for strings.</p> Source code in <code>basemkit/yamlable.py</code> <pre><code>def represent_literal(self, dumper: yaml.Dumper, data: str) -&gt; yaml.Node:\n    \"\"\"\n    Custom representer for block scalar style for strings.\n    \"\"\"\n    if \"\\n\" in data:\n        return dumper.represent_scalar(\"tag:yaml.org,2002:str\", data, style=\"|\")\n    return dumper.represent_scalar(\"tag:yaml.org,2002:str\", data)\n</code></pre>"},{"location":"#basemkit.yamlable.YamlAble.represent_none","title":"<code>represent_none(_, __)</code>","text":"<p>Custom representer for ignoring None values in the YAML output.</p> Source code in <code>basemkit/yamlable.py</code> <pre><code>def represent_none(self, _, __) -&gt; yaml.Node:\n    \"\"\"\n    Custom representer for ignoring None values in the YAML output.\n    \"\"\"\n    return self._yaml_dumper.represent_scalar(\"tag:yaml.org,2002:null\", \"\")\n</code></pre>"},{"location":"#basemkit.yamlable.YamlAble.save_to_json_file","title":"<code>save_to_json_file(filename, **kwargs)</code>","text":"<p>Saves the current dataclass instance to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path where the JSON file will be saved.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for the <code>to_json</code> method.</p> <code>{}</code> Source code in <code>basemkit/yamlable.py</code> <pre><code>def save_to_json_file(self, filename: str, **kwargs: Any):\n    \"\"\"\n    Saves the current dataclass instance to a JSON file.\n\n    Args:\n        filename (str): The path where the JSON file will be saved.\n        **kwargs: Additional keyword arguments for the `to_json` method.\n    \"\"\"\n    json_content: str = self.to_json(**kwargs)\n    with open(filename, \"w\", encoding=\"utf-8\") as file:\n        file.write(json_content)\n</code></pre>"},{"location":"#basemkit.yamlable.YamlAble.save_to_yaml_file","title":"<code>save_to_yaml_file(filename)</code>","text":"<p>Saves the current dataclass instance to a YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path where the YAML file will be saved.</p> required Source code in <code>basemkit/yamlable.py</code> <pre><code>def save_to_yaml_file(self, filename: str):\n    \"\"\"\n    Saves the current dataclass instance to a YAML file.\n\n    Args:\n        filename (str): The path where the YAML file will be saved.\n    \"\"\"\n\n    with open(filename, \"w\", encoding=\"utf-8\") as file:\n        self.save_to_yaml_stream(file)\n</code></pre>"},{"location":"#basemkit.yamlable.YamlAble.save_to_yaml_stream","title":"<code>save_to_yaml_stream(file)</code>","text":"<p>Saves the current dataclass instance to the given YAML stream.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>TextIO</code> <p>The stream to which YAML content will be saved.</p> required Source code in <code>basemkit/yamlable.py</code> <pre><code>def save_to_yaml_stream(self, file: TextIO):\n    \"\"\"\n    Saves the current dataclass instance to the given YAML stream.\n\n    Args:\n        file (TextIO): The stream to which YAML content will be saved.\n    \"\"\"\n    yaml_content: str = self.to_yaml()\n    file.write(yaml_content)\n</code></pre>"},{"location":"#basemkit.yamlable.YamlAble.to_yaml","title":"<code>to_yaml(ignore_none=True, ignore_underscore=True, allow_unicode=True, sort_keys=False)</code>","text":"<p>Converts this dataclass object to a YAML string, with options to omit None values and/or underscore-prefixed variables, and using block scalar style for strings.</p> <p>Parameters:</p> Name Type Description Default <code>ignore_none</code> <code>bool</code> <p>Flag to indicate whether None values should be removed from the YAML output.</p> <code>True</code> <code>ignore_underscore</code> <code>bool</code> <p>Flag to indicate whether attributes starting with an underscore should be excluded from the YAML output.</p> <code>True</code> <code>allow_unicode</code> <code>bool</code> <p>Flag to indicate whether to allow unicode characters in the output.</p> <code>True</code> <code>sort_keys</code> <code>bool</code> <p>Flag to indicate whether to sort the dictionary keys in the output.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>A string representation of the dataclass object in YAML format.</p> Source code in <code>basemkit/yamlable.py</code> <pre><code>def to_yaml(\n    self,\n    ignore_none: bool = True,\n    ignore_underscore: bool = True,\n    allow_unicode: bool = True,\n    sort_keys: bool = False,\n) -&gt; str:\n    \"\"\"\n    Converts this dataclass object to a YAML string, with options to omit None values and/or underscore-prefixed variables,\n    and using block scalar style for strings.\n\n    Args:\n        ignore_none: Flag to indicate whether None values should be removed from the YAML output.\n        ignore_underscore: Flag to indicate whether attributes starting with an underscore should be excluded from the YAML output.\n        allow_unicode: Flag to indicate whether to allow unicode characters in the output.\n        sort_keys: Flag to indicate whether to sort the dictionary keys in the output.\n\n    Returns:\n        A string representation of the dataclass object in YAML format.\n    \"\"\"\n    obj_dict = asdict(self)\n    self._yaml_setup()\n    clean_dict = self.remove_ignored_values(obj_dict, ignore_none, ignore_underscore)\n    yaml_str = yaml.dump(\n        clean_dict,\n        Dumper=self._yaml_dumper,\n        default_flow_style=False,\n        allow_unicode=allow_unicode,\n        sort_keys=sort_keys,\n    )\n    return yaml_str\n</code></pre>"},{"location":"#basemkit.yamlable.lod_storable","title":"<code>lod_storable(cls)</code>","text":"<p>Decorator to make a class LoDStorable by inheriting from YamlAble. This decorator also ensures the class is a dataclass and has JSON serialization/deserialization capabilities.</p> Source code in <code>basemkit/yamlable.py</code> <pre><code>def lod_storable(cls):\n    \"\"\"\n    Decorator to make a class LoDStorable by\n    inheriting from YamlAble.\n    This decorator also ensures the class is a\n    dataclass and has JSON serialization/deserialization\n    capabilities.\n    \"\"\"\n    cls = dataclass(cls)  # Apply the @dataclass decorator\n    cls = dataclass_json(cls)  # Apply the @dataclass_json decorator\n\n    class LoDStorable(YamlAble, cls):\n        \"\"\"\n        decorator class\n        \"\"\"\n\n        __qualname__ = cls.__qualname__\n        pass\n\n    LoDStorable.__name__ = cls.__name__\n    LoDStorable.__doc__ = cls.__doc__\n\n    return LoDStorable\n</code></pre>"}]}