{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pybasemkit API Documentation","text":""},{"location":"#basemkit.basetest","title":"<code>basetest</code>","text":"<p>Created on 2021-08-19</p> <p>@author: wf</p>"},{"location":"#basemkit.basetest.Basetest","title":"<code>Basetest</code>","text":"<p>               Bases: <code>TestCase</code></p> <p>base test case</p> Source code in <code>basemkit/basetest.py</code> <pre><code>class Basetest(unittest.TestCase):\n    \"\"\"\n    base test case\n    \"\"\"\n\n    def setUp(self, debug=False, profile=True):\n        \"\"\"\n        setUp test environment\n        \"\"\"\n        unittest.TestCase.setUp(self)\n        self.debug = debug\n        self.profile = profile\n        msg = f\"test {self._testMethodName}, debug={self.debug}\"\n        self.profiler = Profiler(msg, profile=self.profile)\n\n    def tearDown(self):\n        unittest.TestCase.tearDown(self)\n        self.profiler.time()\n\n    @staticmethod\n    def inPublicCI():\n        \"\"\"\n        are we running in a public Continuous Integration Environment?\n        \"\"\"\n        publicCI = getpass.getuser() in [\"travis\", \"runner\"]\n        jenkins = \"JENKINS_HOME\" in os.environ\n        return publicCI or jenkins\n\n    @staticmethod\n    def isUser(name: str):\n        \"\"\"Checks if the system has the given name\"\"\"\n        return getpass.getuser() == name\n\n    @staticmethod\n    def timeout(seconds: float)-&gt;Callable:\n        \"\"\"\n        Decorator to enforce a timeout on test methods.\n\n        Args:\n            seconds (float): Timeout duration in seconds.\n\n        Returns:\n            Callable: A decorator that wraps a function and raises TimeoutError\n                      if it exceeds the allowed execution time.\n\n        Raises:\n            TimeoutError: If the wrapped function exceeds the timeout.\n            Exception: If the wrapped function raises any other exception.\n        \"\"\"\n\n        def decorator(func):\n            @wraps(func)\n            def wrapper(*args, **kwargs):\n                result = [None]\n                exception = [None]\n\n                def target():\n                    try:\n                        result[0] = func(*args, **kwargs)\n                    except Exception as e:\n                        exception[0] = e\n\n                thread = threading.Thread(target=target)\n                thread.start()\n                thread.join(seconds)\n\n                if thread.is_alive():\n                    raise TimeoutError(f\"Test timed out after {seconds} seconds\")\n\n                if exception[0] is not None:\n                    raise exception[0]\n\n                return result[0]\n\n            return wrapper\n\n        return decorator\n</code></pre>"},{"location":"#basemkit.basetest.Basetest.inPublicCI","title":"<code>inPublicCI()</code>  <code>staticmethod</code>","text":"<p>are we running in a public Continuous Integration Environment?</p> Source code in <code>basemkit/basetest.py</code> <pre><code>@staticmethod\ndef inPublicCI():\n    \"\"\"\n    are we running in a public Continuous Integration Environment?\n    \"\"\"\n    publicCI = getpass.getuser() in [\"travis\", \"runner\"]\n    jenkins = \"JENKINS_HOME\" in os.environ\n    return publicCI or jenkins\n</code></pre>"},{"location":"#basemkit.basetest.Basetest.isUser","title":"<code>isUser(name)</code>  <code>staticmethod</code>","text":"<p>Checks if the system has the given name</p> Source code in <code>basemkit/basetest.py</code> <pre><code>@staticmethod\ndef isUser(name: str):\n    \"\"\"Checks if the system has the given name\"\"\"\n    return getpass.getuser() == name\n</code></pre>"},{"location":"#basemkit.basetest.Basetest.setUp","title":"<code>setUp(debug=False, profile=True)</code>","text":"<p>setUp test environment</p> Source code in <code>basemkit/basetest.py</code> <pre><code>def setUp(self, debug=False, profile=True):\n    \"\"\"\n    setUp test environment\n    \"\"\"\n    unittest.TestCase.setUp(self)\n    self.debug = debug\n    self.profile = profile\n    msg = f\"test {self._testMethodName}, debug={self.debug}\"\n    self.profiler = Profiler(msg, profile=self.profile)\n</code></pre>"},{"location":"#basemkit.basetest.Basetest.timeout","title":"<code>timeout(seconds)</code>  <code>staticmethod</code>","text":"<p>Decorator to enforce a timeout on test methods.</p> <p>Parameters:</p> Name Type Description Default <code>seconds</code> <code>float</code> <p>Timeout duration in seconds.</p> required <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable</code> <p>A decorator that wraps a function and raises TimeoutError       if it exceeds the allowed execution time.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the wrapped function exceeds the timeout.</p> <code>Exception</code> <p>If the wrapped function raises any other exception.</p> Source code in <code>basemkit/basetest.py</code> <pre><code>@staticmethod\ndef timeout(seconds: float)-&gt;Callable:\n    \"\"\"\n    Decorator to enforce a timeout on test methods.\n\n    Args:\n        seconds (float): Timeout duration in seconds.\n\n    Returns:\n        Callable: A decorator that wraps a function and raises TimeoutError\n                  if it exceeds the allowed execution time.\n\n    Raises:\n        TimeoutError: If the wrapped function exceeds the timeout.\n        Exception: If the wrapped function raises any other exception.\n    \"\"\"\n\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            result = [None]\n            exception = [None]\n\n            def target():\n                try:\n                    result[0] = func(*args, **kwargs)\n                except Exception as e:\n                    exception[0] = e\n\n            thread = threading.Thread(target=target)\n            thread.start()\n            thread.join(seconds)\n\n            if thread.is_alive():\n                raise TimeoutError(f\"Test timed out after {seconds} seconds\")\n\n            if exception[0] is not None:\n                raise exception[0]\n\n            return result[0]\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"#basemkit.profiler","title":"<code>profiler</code>","text":"<p>Created on 2022-11-18</p> <p>@author: wf</p>"},{"location":"#basemkit.profiler.Profiler","title":"<code>Profiler</code>","text":"<p>simple profiler</p> Source code in <code>basemkit/profiler.py</code> <pre><code>class Profiler:\n    \"\"\"\n    simple profiler\n    \"\"\"\n\n    def __init__(self, msg:str, profile=True, with_start: bool = True):\n        \"\"\"\n        Construct the profiler with the given message and flags.\n\n        Args:\n            msg (str): The message to show if profiling is active.\n            profile (bool): True if profiling messages should be shown.\n            with_start (bool): If True, show start message immediately.\n        \"\"\"\n        self.msg = msg\n        self.profile = profile\n        if with_start:\n            self.start()\n\n    def start(self):\n        \"\"\"\n        start profiling\n        \"\"\"\n        self.starttime = time.time()\n        if self.profile:\n            print(f\"Starting {self.msg} ...\")\n\n    def time(self, extraMsg:str=\"\"):\n        \"\"\"\n        time the action and print if profile is active\n        \"\"\"\n        elapsed = time.time() - self.starttime\n        if self.profile:\n            print(f\"{self.msg}{extraMsg} took {elapsed:5.1f} s\")\n        return elapsed\n</code></pre>"},{"location":"#basemkit.profiler.Profiler.__init__","title":"<code>__init__(msg, profile=True, with_start=True)</code>","text":"<p>Construct the profiler with the given message and flags.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message to show if profiling is active.</p> required <code>profile</code> <code>bool</code> <p>True if profiling messages should be shown.</p> <code>True</code> <code>with_start</code> <code>bool</code> <p>If True, show start message immediately.</p> <code>True</code> Source code in <code>basemkit/profiler.py</code> <pre><code>def __init__(self, msg:str, profile=True, with_start: bool = True):\n    \"\"\"\n    Construct the profiler with the given message and flags.\n\n    Args:\n        msg (str): The message to show if profiling is active.\n        profile (bool): True if profiling messages should be shown.\n        with_start (bool): If True, show start message immediately.\n    \"\"\"\n    self.msg = msg\n    self.profile = profile\n    if with_start:\n        self.start()\n</code></pre>"},{"location":"#basemkit.profiler.Profiler.start","title":"<code>start()</code>","text":"<p>start profiling</p> Source code in <code>basemkit/profiler.py</code> <pre><code>def start(self):\n    \"\"\"\n    start profiling\n    \"\"\"\n    self.starttime = time.time()\n    if self.profile:\n        print(f\"Starting {self.msg} ...\")\n</code></pre>"},{"location":"#basemkit.profiler.Profiler.time","title":"<code>time(extraMsg='')</code>","text":"<p>time the action and print if profile is active</p> Source code in <code>basemkit/profiler.py</code> <pre><code>def time(self, extraMsg:str=\"\"):\n    \"\"\"\n    time the action and print if profile is active\n    \"\"\"\n    elapsed = time.time() - self.starttime\n    if self.profile:\n        print(f\"{self.msg}{extraMsg} took {elapsed:5.1f} s\")\n    return elapsed\n</code></pre>"},{"location":"#basemkit.yamlable","title":"<code>yamlable</code>","text":"<p>Created on 2023-12-08, Extended on 2023-16-12 and 2024-01-25</p> <p>@author: wf, ChatGPT</p> <p>Prompts for the development and extension of the 'YamlAble' class within the 'yamable' module:</p> <ol> <li>Develop 'YamlAble' class in 'yamable' module. It    should convert dataclass instances to/from YAML.</li> <li>Implement methods for YAML block scalar style and    exclude None values in 'YamlAble' class.</li> <li>Add functionality to remove None values from    dataclass instances before YAML conversion.</li> <li>Ensure 'YamlAble' processes only dataclass instances,    with error handling for non-dataclass objects.</li> <li>Extend 'YamlAble' for JSON serialization and    deserialization.</li> <li>Add methods for saving/loading dataclass instances    to/from YAML and JSON files in 'YamlAble'.</li> <li>Implement loading of dataclass instances from URLs    for both YAML and JSON in 'YamlAble'.</li> <li>Write tests for 'YamlAble' within the pyLodStorage context.    Use 'samples 2' example from pyLoDStorage    https://github.com/WolfgangFahl/pyLoDStorage/blob/master/lodstorage/sample2.py    as a reference.</li> <li>Ensure tests cover YAML/JSON serialization, deserialization,    and file I/O operations, using the sample-based approach..</li> <li>Use Google-style docstrings, comments, and type hints    in 'YamlAble' class and tests.</li> <li>Adhere to instructions and seek clarification for     any uncertainties.</li> <li>Add @lod_storable annotation support that will automatically     YamlAble support and add @dataclass and @dataclass_json     prerequisite behavior to a class</li> </ol>"},{"location":"#basemkit.yamlable.DateConvert","title":"<code>DateConvert</code>","text":"<p>date converter</p> Source code in <code>basemkit/yamlable.py</code> <pre><code>class DateConvert:\n    \"\"\"\n    date converter\n    \"\"\"\n\n    @classmethod\n    def iso_date_to_datetime(cls, iso_date: str) -&gt; date:\n        date = datetime.strptime(iso_date, \"%Y-%m-%d\").date() if iso_date else None\n        return date\n</code></pre>"},{"location":"#basemkit.yamlable.YamlAble","title":"<code>YamlAble</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>An extended YAML handler class for converting dataclass objects to and from YAML format, and handling loading from and saving to files and URLs.</p> Source code in <code>basemkit/yamlable.py</code> <pre><code>class YamlAble(Generic[T]):\n    \"\"\"\n    An extended YAML handler class for converting dataclass objects to and from YAML format,\n    and handling loading from and saving to files and URLs.\n    \"\"\"\n\n    def _yaml_setup(self):\n        \"\"\"\n        Initializes the YamAble handler, setting up custom representers and preparing it for various operations.\n        \"\"\"\n        if not is_dataclass(self):\n            raise ValueError(\"I must be a dataclass instance.\")\n        if not hasattr(self, \"_yaml_dumper\"):\n            self._yaml_dumper = yaml.Dumper\n            self._yaml_dumper.ignore_aliases = lambda *_args: True\n            self._yaml_dumper.add_representer(type(None), self.represent_none)\n            self._yaml_dumper.add_representer(str, self.represent_literal)\n\n    def represent_none(self, _, __) -&gt; yaml.Node:\n        \"\"\"\n        Custom representer for ignoring None values in the YAML output.\n        \"\"\"\n        return self._yaml_dumper.represent_scalar(\"tag:yaml.org,2002:null\", \"\")\n\n    def represent_literal(self, dumper: yaml.Dumper, data: str) -&gt; yaml.Node:\n        \"\"\"\n        Custom representer for block scalar style for strings.\n        \"\"\"\n        if \"\\n\" in data:\n            return dumper.represent_scalar(\"tag:yaml.org,2002:str\", data, style=\"|\")\n        return dumper.represent_scalar(\"tag:yaml.org,2002:str\", data)\n\n    def to_yaml(\n        self,\n        ignore_none: bool = True,\n        ignore_underscore: bool = True,\n        allow_unicode: bool = True,\n        sort_keys: bool = False,\n    ) -&gt; str:\n        \"\"\"\n        Converts this dataclass object to a YAML string, with options to omit None values and/or underscore-prefixed variables,\n        and using block scalar style for strings.\n\n        Args:\n            ignore_none: Flag to indicate whether None values should be removed from the YAML output.\n            ignore_underscore: Flag to indicate whether attributes starting with an underscore should be excluded from the YAML output.\n            allow_unicode: Flag to indicate whether to allow unicode characters in the output.\n            sort_keys: Flag to indicate whether to sort the dictionary keys in the output.\n\n        Returns:\n            A string representation of the dataclass object in YAML format.\n        \"\"\"\n        obj_dict = asdict(self)\n        self._yaml_setup()\n        clean_dict = self.remove_ignored_values(obj_dict, ignore_none, ignore_underscore)\n        yaml_str = yaml.dump(\n            clean_dict,\n            Dumper=self._yaml_dumper,\n            default_flow_style=False,\n            allow_unicode=allow_unicode,\n            sort_keys=sort_keys,\n        )\n        return yaml_str\n\n    @classmethod\n    def from_yaml(cls: Type[T], yaml_str: str) -&gt; T:\n        \"\"\"\n        Deserializes a YAML string to a dataclass instance.\n\n        Args:\n            yaml_str (str): A string containing YAML formatted data.\n\n        Returns:\n            T: An instance of the dataclass.\n        \"\"\"\n        data: dict[str, Any] = yaml.safe_load(yaml_str)\n        instance: T = cls.from_dict(data)\n        return instance\n\n    @classmethod\n    def load_from_yaml_stream(cls: Type[T], stream: TextIO) -&gt; T:\n        \"\"\"\n        Loads a dataclass instance from a YAML stream.\n\n        Args:\n            stream (TextIO): The input stream containing YAML data.\n\n        Returns:\n            T: An instance of the dataclass.\n        \"\"\"\n        yaml_str: str = stream.read()\n        instance: T = cls.from_yaml(yaml_str)\n        return instance\n\n    @classmethod\n    def load_from_yaml_file(cls: Type[T], filename: str) -&gt; T:\n        \"\"\"\n        Loads a dataclass instance from a YAML file.\n\n        Args:\n            filename (str): The path to the YAML file.\n\n        Returns:\n            T: An instance of the dataclass.\n        \"\"\"\n        with open(filename, \"r\") as file:\n            return cls.load_from_yaml_stream(file)\n\n    @classmethod\n    def load_from_yaml_url(cls: Type[T], url: str) -&gt; T:\n        \"\"\"\n        Loads a dataclass instance from a YAML string obtained from a URL.\n\n        Args:\n            url (str): The URL pointing to the YAML data.\n\n        Returns:\n            T: An instance of the dataclass.\n        \"\"\"\n        yaml_str: str = cls.read_from_url(url)\n        instance: T = cls.from_yaml(yaml_str)\n        return instance\n\n    def save_to_yaml_stream(self, file: TextIO):\n        \"\"\"\n        Saves the current dataclass instance to the given YAML stream.\n\n        Args:\n            file (TextIO): The stream to which YAML content will be saved.\n        \"\"\"\n        yaml_content: str = self.to_yaml()\n        file.write(yaml_content)\n\n    def save_to_yaml_file(self, filename: str):\n        \"\"\"\n        Saves the current dataclass instance to a YAML file.\n\n        Args:\n            filename (str): The path where the YAML file will be saved.\n        \"\"\"\n\n        with open(filename, \"w\", encoding=\"utf-8\") as file:\n            self.save_to_yaml_stream(file)\n\n    @classmethod\n    def load_from_json_file(cls: Type[T], filename: Union[str, Path]) -&gt; T:\n        \"\"\"\n        Loads a dataclass instance from a JSON file.\n\n        Args:\n            filename (str): The path to the JSON file.\n\n        Returns:\n            T: An instance of the dataclass.\n        \"\"\"\n        with open(filename, \"r\", encoding=\"utf-8\") as file:\n            json_str: str = file.read()\n        instance: T = cls.from_json(json_str)\n        return instance\n\n    @classmethod\n    def load_from_json_url(cls: Type[T], url: str) -&gt; T:\n        \"\"\"\n        Loads a dataclass instance from a JSON string obtained from a URL.\n\n        Args:\n            url (str): The URL pointing to the JSON data.\n\n        Returns:\n            T: An instance of the dataclass.\n        \"\"\"\n        json_str: str = cls.read_from_url(url)\n        instance: T = cls.from_json(json_str)\n        return instance\n\n    def save_to_json_file(self, filename: str, **kwargs: Any):\n        \"\"\"\n        Saves the current dataclass instance to a JSON file.\n\n        Args:\n            filename (str): The path where the JSON file will be saved.\n            **kwargs: Additional keyword arguments for the `to_json` method.\n        \"\"\"\n        json_content: str = self.to_json(**kwargs)\n        with open(filename, \"w\", encoding=\"utf-8\") as file:\n            file.write(json_content)\n\n    @classmethod\n    def read_from_url(cls, url: str) -&gt; str:\n        \"\"\"\n        Helper method to fetch content from a URL.\n        \"\"\"\n        with urllib.request.urlopen(url) as response:\n            if response.status == 200:\n                return response.read().decode()\n            else:\n                raise Exception(f\"Unable to load data from URL: {url}\")\n\n    @classmethod\n    def remove_ignored_values(\n        cls,\n        value: Any,\n        ignore_none: bool = True,\n        ignore_underscore: bool = False,\n        ignore_empty: bool = True,\n    ) -&gt; Any:\n        \"\"\"\n        Recursively removes specified types of values from a dictionary or list.\n        By default, it removes keys with None values. Optionally, it can also remove keys starting with an underscore.\n\n        Args:\n            value: The value to process (dictionary, list, or other).\n            ignore_none: Flag to indicate whether None values should be removed.\n            ignore_underscore: Flag to indicate whether keys starting with an underscore should be removed.\n            ignore_empty: Flag to indicate whether empty collections should be removed.\n        \"\"\"\n\n        def is_valid(v):\n            \"\"\"Check if the value is valid based on the specified flags.\"\"\"\n            if ignore_none and v is None:\n                return False\n            if ignore_empty:\n                if isinstance(v, Mapping) and not v:\n                    return False  # Empty dictionary\n                if isinstance(v, Iterable) and not isinstance(v, (str, bytes)) and not v:\n                    return False  # Empty list, set, tuple, etc., but not string or bytes\n            return True\n\n        if isinstance(value, Mapping):\n            value = {\n                k: YamlAble.remove_ignored_values(v, ignore_none, ignore_underscore, ignore_empty)\n                for k, v in value.items()\n                if is_valid(v) and (not ignore_underscore or not k.startswith(\"_\"))\n            }\n        elif isinstance(value, Iterable) and not isinstance(value, (str, bytes)):\n            value = [\n                YamlAble.remove_ignored_values(v, ignore_none, ignore_underscore, ignore_empty)\n                for v in value\n                if is_valid(v)\n            ]\n        return value\n\n    @classmethod\n    def from_dict2(cls: Type[T], data: dict) -&gt; T:\n        \"\"\"\n        Creates an instance of a dataclass from a dictionary, typically used in deserialization.\n        \"\"\"\n        if not data:\n            return None\n        instance = from_dict(data_class=cls, data=data)\n        return instance\n</code></pre>"},{"location":"#basemkit.yamlable.YamlAble.from_dict2","title":"<code>from_dict2(data)</code>  <code>classmethod</code>","text":"<p>Creates an instance of a dataclass from a dictionary, typically used in deserialization.</p> Source code in <code>basemkit/yamlable.py</code> <pre><code>@classmethod\ndef from_dict2(cls: Type[T], data: dict) -&gt; T:\n    \"\"\"\n    Creates an instance of a dataclass from a dictionary, typically used in deserialization.\n    \"\"\"\n    if not data:\n        return None\n    instance = from_dict(data_class=cls, data=data)\n    return instance\n</code></pre>"},{"location":"#basemkit.yamlable.YamlAble.from_yaml","title":"<code>from_yaml(yaml_str)</code>  <code>classmethod</code>","text":"<p>Deserializes a YAML string to a dataclass instance.</p> <p>Parameters:</p> Name Type Description Default <code>yaml_str</code> <code>str</code> <p>A string containing YAML formatted data.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>An instance of the dataclass.</p> Source code in <code>basemkit/yamlable.py</code> <pre><code>@classmethod\ndef from_yaml(cls: Type[T], yaml_str: str) -&gt; T:\n    \"\"\"\n    Deserializes a YAML string to a dataclass instance.\n\n    Args:\n        yaml_str (str): A string containing YAML formatted data.\n\n    Returns:\n        T: An instance of the dataclass.\n    \"\"\"\n    data: dict[str, Any] = yaml.safe_load(yaml_str)\n    instance: T = cls.from_dict(data)\n    return instance\n</code></pre>"},{"location":"#basemkit.yamlable.YamlAble.load_from_json_file","title":"<code>load_from_json_file(filename)</code>  <code>classmethod</code>","text":"<p>Loads a dataclass instance from a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the JSON file.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>An instance of the dataclass.</p> Source code in <code>basemkit/yamlable.py</code> <pre><code>@classmethod\ndef load_from_json_file(cls: Type[T], filename: Union[str, Path]) -&gt; T:\n    \"\"\"\n    Loads a dataclass instance from a JSON file.\n\n    Args:\n        filename (str): The path to the JSON file.\n\n    Returns:\n        T: An instance of the dataclass.\n    \"\"\"\n    with open(filename, \"r\", encoding=\"utf-8\") as file:\n        json_str: str = file.read()\n    instance: T = cls.from_json(json_str)\n    return instance\n</code></pre>"},{"location":"#basemkit.yamlable.YamlAble.load_from_json_url","title":"<code>load_from_json_url(url)</code>  <code>classmethod</code>","text":"<p>Loads a dataclass instance from a JSON string obtained from a URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL pointing to the JSON data.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>An instance of the dataclass.</p> Source code in <code>basemkit/yamlable.py</code> <pre><code>@classmethod\ndef load_from_json_url(cls: Type[T], url: str) -&gt; T:\n    \"\"\"\n    Loads a dataclass instance from a JSON string obtained from a URL.\n\n    Args:\n        url (str): The URL pointing to the JSON data.\n\n    Returns:\n        T: An instance of the dataclass.\n    \"\"\"\n    json_str: str = cls.read_from_url(url)\n    instance: T = cls.from_json(json_str)\n    return instance\n</code></pre>"},{"location":"#basemkit.yamlable.YamlAble.load_from_yaml_file","title":"<code>load_from_yaml_file(filename)</code>  <code>classmethod</code>","text":"<p>Loads a dataclass instance from a YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the YAML file.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>An instance of the dataclass.</p> Source code in <code>basemkit/yamlable.py</code> <pre><code>@classmethod\ndef load_from_yaml_file(cls: Type[T], filename: str) -&gt; T:\n    \"\"\"\n    Loads a dataclass instance from a YAML file.\n\n    Args:\n        filename (str): The path to the YAML file.\n\n    Returns:\n        T: An instance of the dataclass.\n    \"\"\"\n    with open(filename, \"r\") as file:\n        return cls.load_from_yaml_stream(file)\n</code></pre>"},{"location":"#basemkit.yamlable.YamlAble.load_from_yaml_stream","title":"<code>load_from_yaml_stream(stream)</code>  <code>classmethod</code>","text":"<p>Loads a dataclass instance from a YAML stream.</p> <p>Parameters:</p> Name Type Description Default <code>stream</code> <code>TextIO</code> <p>The input stream containing YAML data.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>An instance of the dataclass.</p> Source code in <code>basemkit/yamlable.py</code> <pre><code>@classmethod\ndef load_from_yaml_stream(cls: Type[T], stream: TextIO) -&gt; T:\n    \"\"\"\n    Loads a dataclass instance from a YAML stream.\n\n    Args:\n        stream (TextIO): The input stream containing YAML data.\n\n    Returns:\n        T: An instance of the dataclass.\n    \"\"\"\n    yaml_str: str = stream.read()\n    instance: T = cls.from_yaml(yaml_str)\n    return instance\n</code></pre>"},{"location":"#basemkit.yamlable.YamlAble.load_from_yaml_url","title":"<code>load_from_yaml_url(url)</code>  <code>classmethod</code>","text":"<p>Loads a dataclass instance from a YAML string obtained from a URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL pointing to the YAML data.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>An instance of the dataclass.</p> Source code in <code>basemkit/yamlable.py</code> <pre><code>@classmethod\ndef load_from_yaml_url(cls: Type[T], url: str) -&gt; T:\n    \"\"\"\n    Loads a dataclass instance from a YAML string obtained from a URL.\n\n    Args:\n        url (str): The URL pointing to the YAML data.\n\n    Returns:\n        T: An instance of the dataclass.\n    \"\"\"\n    yaml_str: str = cls.read_from_url(url)\n    instance: T = cls.from_yaml(yaml_str)\n    return instance\n</code></pre>"},{"location":"#basemkit.yamlable.YamlAble.read_from_url","title":"<code>read_from_url(url)</code>  <code>classmethod</code>","text":"<p>Helper method to fetch content from a URL.</p> Source code in <code>basemkit/yamlable.py</code> <pre><code>@classmethod\ndef read_from_url(cls, url: str) -&gt; str:\n    \"\"\"\n    Helper method to fetch content from a URL.\n    \"\"\"\n    with urllib.request.urlopen(url) as response:\n        if response.status == 200:\n            return response.read().decode()\n        else:\n            raise Exception(f\"Unable to load data from URL: {url}\")\n</code></pre>"},{"location":"#basemkit.yamlable.YamlAble.remove_ignored_values","title":"<code>remove_ignored_values(value, ignore_none=True, ignore_underscore=False, ignore_empty=True)</code>  <code>classmethod</code>","text":"<p>Recursively removes specified types of values from a dictionary or list. By default, it removes keys with None values. Optionally, it can also remove keys starting with an underscore.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to process (dictionary, list, or other).</p> required <code>ignore_none</code> <code>bool</code> <p>Flag to indicate whether None values should be removed.</p> <code>True</code> <code>ignore_underscore</code> <code>bool</code> <p>Flag to indicate whether keys starting with an underscore should be removed.</p> <code>False</code> <code>ignore_empty</code> <code>bool</code> <p>Flag to indicate whether empty collections should be removed.</p> <code>True</code> Source code in <code>basemkit/yamlable.py</code> <pre><code>@classmethod\ndef remove_ignored_values(\n    cls,\n    value: Any,\n    ignore_none: bool = True,\n    ignore_underscore: bool = False,\n    ignore_empty: bool = True,\n) -&gt; Any:\n    \"\"\"\n    Recursively removes specified types of values from a dictionary or list.\n    By default, it removes keys with None values. Optionally, it can also remove keys starting with an underscore.\n\n    Args:\n        value: The value to process (dictionary, list, or other).\n        ignore_none: Flag to indicate whether None values should be removed.\n        ignore_underscore: Flag to indicate whether keys starting with an underscore should be removed.\n        ignore_empty: Flag to indicate whether empty collections should be removed.\n    \"\"\"\n\n    def is_valid(v):\n        \"\"\"Check if the value is valid based on the specified flags.\"\"\"\n        if ignore_none and v is None:\n            return False\n        if ignore_empty:\n            if isinstance(v, Mapping) and not v:\n                return False  # Empty dictionary\n            if isinstance(v, Iterable) and not isinstance(v, (str, bytes)) and not v:\n                return False  # Empty list, set, tuple, etc., but not string or bytes\n        return True\n\n    if isinstance(value, Mapping):\n        value = {\n            k: YamlAble.remove_ignored_values(v, ignore_none, ignore_underscore, ignore_empty)\n            for k, v in value.items()\n            if is_valid(v) and (not ignore_underscore or not k.startswith(\"_\"))\n        }\n    elif isinstance(value, Iterable) and not isinstance(value, (str, bytes)):\n        value = [\n            YamlAble.remove_ignored_values(v, ignore_none, ignore_underscore, ignore_empty)\n            for v in value\n            if is_valid(v)\n        ]\n    return value\n</code></pre>"},{"location":"#basemkit.yamlable.YamlAble.represent_literal","title":"<code>represent_literal(dumper, data)</code>","text":"<p>Custom representer for block scalar style for strings.</p> Source code in <code>basemkit/yamlable.py</code> <pre><code>def represent_literal(self, dumper: yaml.Dumper, data: str) -&gt; yaml.Node:\n    \"\"\"\n    Custom representer for block scalar style for strings.\n    \"\"\"\n    if \"\\n\" in data:\n        return dumper.represent_scalar(\"tag:yaml.org,2002:str\", data, style=\"|\")\n    return dumper.represent_scalar(\"tag:yaml.org,2002:str\", data)\n</code></pre>"},{"location":"#basemkit.yamlable.YamlAble.represent_none","title":"<code>represent_none(_, __)</code>","text":"<p>Custom representer for ignoring None values in the YAML output.</p> Source code in <code>basemkit/yamlable.py</code> <pre><code>def represent_none(self, _, __) -&gt; yaml.Node:\n    \"\"\"\n    Custom representer for ignoring None values in the YAML output.\n    \"\"\"\n    return self._yaml_dumper.represent_scalar(\"tag:yaml.org,2002:null\", \"\")\n</code></pre>"},{"location":"#basemkit.yamlable.YamlAble.save_to_json_file","title":"<code>save_to_json_file(filename, **kwargs)</code>","text":"<p>Saves the current dataclass instance to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path where the JSON file will be saved.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for the <code>to_json</code> method.</p> <code>{}</code> Source code in <code>basemkit/yamlable.py</code> <pre><code>def save_to_json_file(self, filename: str, **kwargs: Any):\n    \"\"\"\n    Saves the current dataclass instance to a JSON file.\n\n    Args:\n        filename (str): The path where the JSON file will be saved.\n        **kwargs: Additional keyword arguments for the `to_json` method.\n    \"\"\"\n    json_content: str = self.to_json(**kwargs)\n    with open(filename, \"w\", encoding=\"utf-8\") as file:\n        file.write(json_content)\n</code></pre>"},{"location":"#basemkit.yamlable.YamlAble.save_to_yaml_file","title":"<code>save_to_yaml_file(filename)</code>","text":"<p>Saves the current dataclass instance to a YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path where the YAML file will be saved.</p> required Source code in <code>basemkit/yamlable.py</code> <pre><code>def save_to_yaml_file(self, filename: str):\n    \"\"\"\n    Saves the current dataclass instance to a YAML file.\n\n    Args:\n        filename (str): The path where the YAML file will be saved.\n    \"\"\"\n\n    with open(filename, \"w\", encoding=\"utf-8\") as file:\n        self.save_to_yaml_stream(file)\n</code></pre>"},{"location":"#basemkit.yamlable.YamlAble.save_to_yaml_stream","title":"<code>save_to_yaml_stream(file)</code>","text":"<p>Saves the current dataclass instance to the given YAML stream.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>TextIO</code> <p>The stream to which YAML content will be saved.</p> required Source code in <code>basemkit/yamlable.py</code> <pre><code>def save_to_yaml_stream(self, file: TextIO):\n    \"\"\"\n    Saves the current dataclass instance to the given YAML stream.\n\n    Args:\n        file (TextIO): The stream to which YAML content will be saved.\n    \"\"\"\n    yaml_content: str = self.to_yaml()\n    file.write(yaml_content)\n</code></pre>"},{"location":"#basemkit.yamlable.YamlAble.to_yaml","title":"<code>to_yaml(ignore_none=True, ignore_underscore=True, allow_unicode=True, sort_keys=False)</code>","text":"<p>Converts this dataclass object to a YAML string, with options to omit None values and/or underscore-prefixed variables, and using block scalar style for strings.</p> <p>Parameters:</p> Name Type Description Default <code>ignore_none</code> <code>bool</code> <p>Flag to indicate whether None values should be removed from the YAML output.</p> <code>True</code> <code>ignore_underscore</code> <code>bool</code> <p>Flag to indicate whether attributes starting with an underscore should be excluded from the YAML output.</p> <code>True</code> <code>allow_unicode</code> <code>bool</code> <p>Flag to indicate whether to allow unicode characters in the output.</p> <code>True</code> <code>sort_keys</code> <code>bool</code> <p>Flag to indicate whether to sort the dictionary keys in the output.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>A string representation of the dataclass object in YAML format.</p> Source code in <code>basemkit/yamlable.py</code> <pre><code>def to_yaml(\n    self,\n    ignore_none: bool = True,\n    ignore_underscore: bool = True,\n    allow_unicode: bool = True,\n    sort_keys: bool = False,\n) -&gt; str:\n    \"\"\"\n    Converts this dataclass object to a YAML string, with options to omit None values and/or underscore-prefixed variables,\n    and using block scalar style for strings.\n\n    Args:\n        ignore_none: Flag to indicate whether None values should be removed from the YAML output.\n        ignore_underscore: Flag to indicate whether attributes starting with an underscore should be excluded from the YAML output.\n        allow_unicode: Flag to indicate whether to allow unicode characters in the output.\n        sort_keys: Flag to indicate whether to sort the dictionary keys in the output.\n\n    Returns:\n        A string representation of the dataclass object in YAML format.\n    \"\"\"\n    obj_dict = asdict(self)\n    self._yaml_setup()\n    clean_dict = self.remove_ignored_values(obj_dict, ignore_none, ignore_underscore)\n    yaml_str = yaml.dump(\n        clean_dict,\n        Dumper=self._yaml_dumper,\n        default_flow_style=False,\n        allow_unicode=allow_unicode,\n        sort_keys=sort_keys,\n    )\n    return yaml_str\n</code></pre>"},{"location":"#basemkit.yamlable.lod_storable","title":"<code>lod_storable(cls)</code>","text":"<p>Decorator to make a class LoDStorable by inheriting from YamlAble. This decorator also ensures the class is a dataclass and has JSON serialization/deserialization capabilities.</p> Source code in <code>basemkit/yamlable.py</code> <pre><code>def lod_storable(cls):\n    \"\"\"\n    Decorator to make a class LoDStorable by\n    inheriting from YamlAble.\n    This decorator also ensures the class is a\n    dataclass and has JSON serialization/deserialization\n    capabilities.\n    \"\"\"\n    cls = dataclass(cls)  # Apply the @dataclass decorator\n    cls = dataclass_json(cls)  # Apply the @dataclass_json decorator\n\n    class LoDStorable(YamlAble, cls):\n        \"\"\"\n        decorator class\n        \"\"\"\n\n        __qualname__ = cls.__qualname__\n        pass\n\n    LoDStorable.__name__ = cls.__name__\n    LoDStorable.__doc__ = cls.__doc__\n\n    return LoDStorable\n</code></pre>"}]}